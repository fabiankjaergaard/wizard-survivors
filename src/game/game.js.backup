// Game Configuration
console.log('WIZARD VERSION 3 LOADING - with sprite animations!');
console.log('Window size:', window.innerWidth, 'x', window.innerHeight);

// Simple Sound System (using Web Audio API to generate sounds)
const SoundSystem = {
    audioContext: null,
    lastHitTime: 0,
    hitThrottle: 50, // Minimum ms between hit sounds

    init() {
        // Create AudioContext on first user interaction
        if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    },

    playHit(type = 'normal') {
        // TEMPORARILY DISABLED FOR PERFORMANCE
        return;

        // Throttle hit sounds to prevent audio overload
        const now = Date.now();
        if (now - this.lastHitTime < this.hitThrottle) {
            return; // Skip this sound
        }
        this.lastHitTime = now;

        this.init();
        const ctx = this.audioContext;
        const audioNow = ctx.currentTime;

        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);

        // Different sounds for different hit types
        switch(type) {
            case 'normal':
                oscillator.frequency.setValueAtTime(800, audioNow);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioNow + 0.1);
                gainNode.gain.setValueAtTime(0.2, audioNow);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioNow + 0.1);
                break;
            case 'critical':
                oscillator.frequency.setValueAtTime(1200, audioNow);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioNow + 0.15);
                gainNode.gain.setValueAtTime(0.25, audioNow);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioNow + 0.15);
                break;
            case 'magic':
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, audioNow);
                oscillator.frequency.exponentialRampToValueAtTime(1200, audioNow + 0.05);
                oscillator.frequency.exponentialRampToValueAtTime(300, audioNow + 0.1);
                gainNode.gain.setValueAtTime(0.15, audioNow);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioNow + 0.1);
                break;
            case 'explosion':
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, audioNow);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioNow + 0.3);
                gainNode.gain.setValueAtTime(0.3, audioNow);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioNow + 0.3);
                break;
        }

        oscillator.start(audioNow);
        oscillator.stop(audioNow + 0.3);
    },

    playShoot(weaponType = 'magic_missile') {
        this.init();
        const ctx = this.audioContext;
        const now = ctx.currentTime;

        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);

        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(400, now);
        oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.05);

        gainNode.gain.setValueAtTime(0.15, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

        oscillator.start(now);
        oscillator.stop(now + 0.05);
    }
};

// Rarity System
const RARITY = {
    COMMON: {
        name: 'Common',
        color: '#9ca3af',
        glowColor: '#6b7280',
        weight: 60, // Drop chance weight
        statMultiplier: 1.0
    },
    RARE: {
        name: 'Rare',
        color: '#3b82f6',
        glowColor: '#60a5fa',
        weight: 25,
        statMultiplier: 1.5
    },
    EPIC: {
        name: 'Epic',
        color: '#a855f7',
        glowColor: '#c084fc',
        weight: 12,
        statMultiplier: 2.0
    },
    LEGENDARY: {
        name: 'Legendary',
        color: '#f59e0b',
        glowColor: '#fbbf24',
        weight: 3,
        statMultiplier: 3.0
    }
};

// Helper function to get random rarity based on weights
function getRandomRarity() {
    const totalWeight = Object.values(RARITY).reduce((sum, r) => sum + r.weight, 0);
    let random = Math.random() * totalWeight;

    for (const [key, rarity] of Object.entries(RARITY)) {
        random -= rarity.weight;
        if (random <= 0) {
            return { key, ...rarity };
        }
    }
    return { key: 'COMMON', ...RARITY.COMMON };
}

const CONFIG = {
    canvas: {
        width: window.innerWidth,
        height: window.innerHeight
    },
    world: {
        width: 8000,  // Much larger map
        height: 8000  // Much larger map
    },
    player: {
        size: 12,
        speed: 2,  // Reduced from 3 to 2
        maxHp: 100
    },
    enemy: {
        size: 15,
        speed: 1.5,
        spawnRate: 1000, // ms (base rate, will decrease over time)
        maxEnemies: 100
    },
    weapon: {
        damage: 10,
        range: 150,
        cooldown: 500 // ms
    },
    difficulty: {
        // Scaling over time - tuned for 20 minute end game
        scalingInterval: 60000, // Every 60 seconds (1 minute)
        speedIncrease: 0.075, // 7.5% speed increase per interval
        hpIncrease: 0.125, // 12.5% HP increase per interval
        damageIncrease: 0.075, // 7.5% damage increase per interval
        spawnRateDecrease: 0.96, // Spawn 4% faster per interval (multiply by 0.96)
        maxEnemiesIncrease: 5, // +5 max enemies per interval
        maxSpeedMultiplier: 3, // Max 3x speed (reached at ~16 min)
        maxHpMultiplier: 6, // Max 6x HP (reached at ~20 min)
        maxDamageMultiplier: 3, // Max 3x damage (reached at ~16 min)
        minSpawnRate: 250, // Minimum 250ms between spawns
        maxEnemiesCap: 250 // Cap at 250 enemies
    }
};

// Difficulty scaling function
function getDifficultyMultipliers() {
    const timeInSeconds = gameState.gameTime / 1000;
    const intervals = Math.floor(timeInSeconds / 60); // Every 60 seconds (1 minute)

    // Calculate multipliers with caps
    const speedMultiplier = Math.min(
        1 + (intervals * CONFIG.difficulty.speedIncrease),
        CONFIG.difficulty.maxSpeedMultiplier
    );

    const hpMultiplier = Math.min(
        1 + (intervals * CONFIG.difficulty.hpIncrease),
        CONFIG.difficulty.maxHpMultiplier
    );

    const damageMultiplier = Math.min(
        1 + (intervals * CONFIG.difficulty.damageIncrease),
        CONFIG.difficulty.maxDamageMultiplier
    );

    const spawnRate = Math.max(
        CONFIG.enemy.spawnRate * Math.pow(CONFIG.difficulty.spawnRateDecrease, intervals),
        CONFIG.difficulty.minSpawnRate
    );

    const maxEnemies = Math.min(
        CONFIG.enemy.maxEnemies + (intervals * CONFIG.difficulty.maxEnemiesIncrease),
        CONFIG.difficulty.maxEnemiesCap
    );

    return {
        speed: speedMultiplier,
        hp: hpMultiplier,
        damage: damageMultiplier,
        spawnRate: spawnRate,
        maxEnemies: maxEnemies,
        intervals: intervals
    };
}

// Camera system
const camera = {
    x: 0,
    y: 0,
    smoothing: 0.15 // How smooth camera follows (higher = faster, less lag)
};

// Helper function to convert world coordinates to screen coordinates
function toScreen(worldX, worldY) {
    return {
        x: worldX - camera.x,
        y: worldY - camera.y
    };
}

// Ultimate Abilities Database
const ULTIMATES = {
    meteor_storm: {
        type: 'meteor_storm',
        name: 'Meteor Storm',
        icon: 'MTR',
        description: 'Rain down meteors across the battlefield',
        cooldown: 60000, // 60 seconds
        duration: 8000, // 8 seconds of meteor rain
        damage: 150,
        execute: () => {
            console.log('METEOR STORM ACTIVATED!');
            gameState.player.ultimateActive = true;
            gameState.meteorStormStartTime = Date.now();
            gameState.meteorStormLastSpawn = Date.now();
        }
    },
    time_freeze: {
        type: 'time_freeze',
        name: 'Temporal Freeze',
        icon: 'TMP',
        description: 'Freeze time for all enemies',
        cooldown: 90000, // 90 seconds
        duration: 5000, // 5 seconds
        execute: () => {
            console.log('TIME FREEZE ACTIVATED!');
            gameState.player.ultimateActive = true;

            // Store original enemy speeds
            gameState.enemies.forEach(enemy => {
                enemy.frozenSpeed = enemy.speed;
                enemy.speed = 0;
                enemy.isFrozen = true;
            });

            setTimeout(() => {
                gameState.enemies.forEach(enemy => {
                    if (enemy.frozenSpeed !== undefined) {
                        enemy.speed = enemy.frozenSpeed;
                        enemy.isFrozen = false;
                    }
                });
                gameState.player.ultimateActive = false;
            }, 5000);
        }
    },
    divine_wrath: {
        type: 'divine_wrath',
        name: 'Divine Wrath',
        icon: 'âš¡',
        description: 'Summon lightning that chains between all enemies',
        cooldown: 75000, // 75 seconds
        damage: 200,
        execute: () => {
            console.log('âš¡ DIVINE WRATH ACTIVATED!');

            if (gameState.enemies.length === 0) return;

            // Create chain lightning that hits ALL enemies
            const hitEnemies = new Set();
            let currentEnemy = gameState.enemies[0];
            hitEnemies.add(currentEnemy);

            const chainInterval = setInterval(() => {
                if (hitEnemies.size >= gameState.enemies.length) {
                    clearInterval(chainInterval);
                    return;
                }

                // Find closest unhit enemy
                let closestEnemy = null;
                let minDist = Infinity;

                gameState.enemies.forEach(enemy => {
                    if (!hitEnemies.has(enemy)) {
                        const dx = enemy.x - currentEnemy.x;
                        const dy = enemy.y - currentEnemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist) {
                            minDist = dist;
                            closestEnemy = enemy;
                        }
                    }
                });

                if (closestEnemy) {
                    // Damage enemy
                    closestEnemy.hp -= 200;

                    // Visual lightning effect
                    gameState.chainLightnings.push({
                        startX: currentEnemy.x,
                        startY: currentEnemy.y,
                        endX: closestEnemy.x,
                        endY: closestEnemy.y,
                        duration: 300
                    });

                    hitEnemies.add(closestEnemy);
                    currentEnemy = closestEnemy;
                }
            }, 100);
        }
    },
    blood_moon: {
        type: 'blood_moon',
        name: 'Blood Moon',
        icon: 'ðŸŒ•',
        description: 'Gain massive damage and lifesteal',
        cooldown: 120000, // 120 seconds (2 minutes)
        duration: 10000, // 10 seconds
        damageMultiplier: 3,
        lifesteal: 0.5, // 50% lifesteal
        execute: () => {
            console.log('ðŸŒ• BLOOD MOON ACTIVATED!');
            gameState.player.ultimateActive = true;
            gameState.bloodMoonActive = true;

            setTimeout(() => {
                gameState.player.ultimateActive = false;
                gameState.bloodMoonActive = false;
            }, 10000);
        }
    },
    apocalypse: {
        type: 'apocalypse',
        name: 'Apocalypse',
        icon: 'ðŸ’€',
        description: 'Instantly kill all enemies on screen',
        cooldown: 180000, // 180 seconds (3 minutes)
        execute: () => {
            console.log('ðŸ’€ APOCALYPSE ACTIVATED!');

            const enemiesKilled = gameState.enemies.length;

            // Kill all enemies and spawn XP orbs
            gameState.enemies.forEach(enemy => {
                // Spawn XP orb
                gameState.xpOrbs.push({
                    x: enemy.x,
                    y: enemy.y,
                    value: enemy.xpValue || 1,
                    radius: 8,
                    pulsePhase: 0
                });

                // Death particles
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    gameState.particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        life: 1,
                        maxLife: 1,
                        color: '#8b5cf6',
                        size: 4
                    });
                }
            });

            gameState.enemies = [];
            gameState.kills += enemiesKilled;

            console.log(`ðŸ’€ Apocalypse killed ${enemiesKilled} enemies!`);
        }
    },
    phoenix_rebirth: {
        type: 'phoenix_rebirth',
        name: 'Phoenix Rebirth',
        icon: 'ðŸ”¥',
        description: 'Resurrect with full HP if you die within 30s',
        cooldown: 300000, // 5 minutes
        duration: 30000, // 30 seconds protection
        rarity: 'rare', // Found in chests
        execute: () => {
            console.log('ðŸ”¥ PHOENIX REBIRTH ACTIVATED!');
            gameState.phoenixRebirth = true;
            gameState.phoenixRebirthExpiry = Date.now() + 30000;

            setTimeout(() => {
                if (gameState.phoenixRebirth) {
                    gameState.phoenixRebirth = false;
                    console.log('ðŸ”¥ Phoenix Rebirth expired');
                }
            }, 30000);
        }
    },
    shadow_clone: {
        type: 'shadow_clone',
        name: 'Shadow Clone',
        icon: 'ðŸ‘¥',
        description: 'Summon 3 clones that copy your attacks',
        cooldown: 90000, // 90 seconds
        duration: 15000, // 15 seconds
        rarity: 'rare',
        execute: () => {
            console.log('ðŸ‘¥ SHADOW CLONE ACTIVATED!');
            gameState.shadowClones = [];

            // Create 3 clones around player
            for (let i = 0; i < 3; i++) {
                const angle = (Math.PI * 2 / 3) * i;
                const distance = 100;
                gameState.shadowClones.push({
                    x: gameState.player.x + Math.cos(angle) * distance,
                    y: gameState.player.y + Math.sin(angle) * distance,
                    targetX: gameState.player.x + Math.cos(angle) * distance,
                    targetY: gameState.player.y + Math.sin(angle) * distance,
                    angle: angle,
                    startTime: Date.now()
                });
            }

            setTimeout(() => {
                gameState.shadowClones = [];
                console.log('ðŸ‘¥ Shadow Clones vanished');
            }, 15000);
        }
    },
    gravity_well: {
        type: 'gravity_well',
        name: 'Gravity Well',
        icon: 'ðŸŒ€',
        description: 'Pull all enemies to center and deal massive damage',
        cooldown: 120000, // 2 minutes
        rarity: 'rare',
        execute: () => {
            console.log('ðŸŒ€ GRAVITY WELL ACTIVATED!');

            const centerX = gameState.player.x;
            const centerY = gameState.player.y;

            // Pull enemies and damage them
            gameState.enemies.forEach(enemy => {
                const dx = centerX - enemy.x;
                const dy = centerY - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 50) {
                    // Pull towards center
                    const pullForce = 20;
                    enemy.x += (dx / distance) * pullForce;
                    enemy.y += (dy / distance) * pullForce;
                }

                // Damage based on distance (closer = more damage)
                const damage = 300 * (1 - Math.min(distance / 500, 1));
                enemy.hp -= damage;
            });

            // Visual effect
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 300;
                gameState.particles.push({
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    vx: -Math.cos(angle) * 10,
                    vy: -Math.sin(angle) * 10,
                    size: 6,
                    color: '#00d9ff',
                    alpha: 1,
                    decay: 0.03,
                    lifetime: 60
                });
            }
        }
    },
    // Achievement-exclusive ultimates (cannot be found in chests)
    titan_form: {
        type: 'titan_form',
        name: 'Titan Form',
        icon: 'TTN',
        description: 'Become invincible and deal 10x damage',
        cooldown: 240000, // 4 minutes
        duration: 10000, // 10 seconds
        achievement: 'kill_1000_enemies', // Requires achievement
        rarity: 'legendary',
        execute: () => {
            console.log('TITAN FORM ACTIVATED!');
            gameState.titanForm = true;
            gameState.player.ultimateActive = true;

            setTimeout(() => {
                gameState.titanForm = false;
                gameState.player.ultimateActive = false;
                console.log('Titan Form ended');
            }, 10000);
        }
    },
    void_rift: {
        type: 'void_rift',
        name: 'Void Rift',
        icon: 'VRF',
        description: 'Open a rift that banishes enemies to the void',
        cooldown: 180000, // 3 minutes
        duration: 8000, // 8 seconds
        achievement: 'survive_20_minutes',
        rarity: 'legendary',
        execute: () => {
            console.log('VOID RIFT ACTIVATED!');

            gameState.voidRift = {
                x: gameState.player.x,
                y: gameState.player.y,
                radius: 0,
                maxRadius: 300,
                startTime: Date.now()
            };

            const riftInterval = setInterval(() => {
                if (!gameState.voidRift) {
                    clearInterval(riftInterval);
                    return;
                }

                // Expand rift
                gameState.voidRift.radius = Math.min(
                    gameState.voidRift.radius + 10,
                    gameState.voidRift.maxRadius
                );

                // Banish enemies in rift
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    const dx = enemy.x - gameState.voidRift.x;
                    const dy = enemy.y - gameState.voidRift.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < gameState.voidRift.radius) {
                        // Banish enemy (instant kill)
                        gameState.xpOrbs.push({
                            x: enemy.x,
                            y: enemy.y,
                            value: enemy.xpValue || 1,
                            radius: 8,
                            pulsePhase: 0
                        });
                        gameState.enemies.splice(i, 1);
                        gameState.kills++;

                        // Void particles
                        for (let j = 0; j < 10; j++) {
                            gameState.particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: (Math.random() - 0.5) * 5,
                                vy: (Math.random() - 0.5) * 5,
                                size: 4,
                                color: '#000000',
                                alpha: 1,
                                decay: 0.05,
                                lifetime: 30
                            });
                        }
                    }
                }
            }, 100);

            setTimeout(() => {
                clearInterval(riftInterval);
                gameState.voidRift = null;
                console.log('Void Rift closed');
            }, 8000);
        }
    },
    cosmic_storm: {
        type: 'cosmic_storm',
        name: 'Cosmic Storm',
        icon: 'CSM',
        description: 'Summon stars that orbit and obliterate enemies',
        cooldown: 150000, // 2.5 minutes
        duration: 12000, // 12 seconds
        achievement: 'kill_boss_without_damage',
        rarity: 'legendary',
        execute: () => {
            console.log('COSMIC STORM ACTIVATED!');

            gameState.cosmicStorm = {
                stars: [],
                startTime: Date.now()
            };

            // Create 8 orbiting stars
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                gameState.cosmicStorm.stars.push({
                    angle: angle,
                    radius: 150,
                    speed: 0.05,
                    damage: 200
                });
            }

            const stormInterval = setInterval(() => {
                if (!gameState.cosmicStorm) {
                    clearInterval(stormInterval);
                    return;
                }

                // Update and damage with stars
                gameState.cosmicStorm.stars.forEach(star => {
                    star.angle += star.speed;
                    const starX = gameState.player.x + Math.cos(star.angle) * star.radius;
                    const starY = gameState.player.y + Math.sin(star.angle) * star.radius;

                    // Damage nearby enemies
                    gameState.enemies.forEach(enemy => {
                        const dx = enemy.x - starX;
                        const dy = enemy.y - starY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 40) {
                            enemy.hp -= star.damage * 0.1; // Damage per tick
                        }
                    });
                });
            }, 100);

            setTimeout(() => {
                clearInterval(stormInterval);
                gameState.cosmicStorm = null;
                console.log('ðŸŒŒ Cosmic Storm ended');
            }, 12000);
        }
    },
    dragons_fury: {
        type: 'dragons_fury',
        name: "Dragon's Fury",
        icon: 'ðŸ‰',
        description: 'Summon a dragon that breathes fire across the battlefield',
        cooldown: 200000, // 3.3 minutes
        achievement: 'reach_level_50',
        rarity: 'legendary',
        execute: () => {
            console.log('ðŸ‰ DRAGONS FURY ACTIVATED!');

            // Dragon starts from top and sweeps fire breath
            gameState.dragonFury = {
                x: gameState.player.x - 400,
                y: gameState.player.y - 400,
                targetX: gameState.player.x + 400,
                targetY: gameState.player.y + 400,
                progress: 0,
                startTime: Date.now()
            };

            const dragonInterval = setInterval(() => {
                if (!gameState.dragonFury) {
                    clearInterval(dragonInterval);
                    return;
                }

                gameState.dragonFury.progress += 0.02;

                const dx = gameState.dragonFury.targetX - gameState.dragonFury.x;
                const dy = gameState.dragonFury.targetY - gameState.dragonFury.y;

                const currentX = gameState.dragonFury.x + dx * gameState.dragonFury.progress;
                const currentY = gameState.dragonFury.y + dy * gameState.dragonFury.progress;

                // Fire breath trail
                for (let i = 0; i < 5; i++) {
                    const offsetX = (Math.random() - 0.5) * 100;
                    const offsetY = (Math.random() - 0.5) * 100;

                    gameState.particles.push({
                        x: currentX + offsetX,
                        y: currentY + offsetY,
                        vx: (Math.random() - 0.5) * 3,
                        vy: (Math.random() - 0.5) * 3,
                        size: 15 + Math.random() * 10,
                        color: Math.random() > 0.5 ? '#ff4500' : '#ff8c00',
                        alpha: 1,
                        decay: 0.03,
                        lifetime: 50
                    });

                    // Damage enemies near fire
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - (currentX + offsetX), 2) +
                            Math.pow(enemy.y - (currentY + offsetY), 2)
                        );

                        if (dist < 80) {
                            enemy.hp -= 50; // Massive damage
                        }
                    });
                }

                if (gameState.dragonFury.progress >= 1) {
                    clearInterval(dragonInterval);
                    gameState.dragonFury = null;
                    console.log('ðŸ‰ Dragon flew away');
                }
            }, 50);
        }
    }
};

// Expose ULTIMATES to window for UI access
window.ULTIMATES = ULTIMATES;

// Achievements Database
const ACHIEVEMENTS = {
    kill_1000_enemies: {
        id: 'kill_1000_enemies',
        name: 'Slayer of Thousands',
        description: 'Kill 1000 enemies',
        icon: 'K1K',
        requirement: {type: 'kills', value: 1000},
        reward: 'titan_form',
        unlocked: false
    },
    survive_20_minutes: {
        id: 'survive_20_minutes',
        name: 'Endurance Master',
        description: 'Survive for 20 minutes',
        icon: 'T20',
        requirement: {type: 'time', value: 1200000}, // 20 minutes in ms
        reward: 'void_rift',
        unlocked: false
    },
    kill_boss_without_damage: {
        id: 'kill_boss_without_damage',
        name: 'Untouchable',
        description: 'Kill a major boss without taking damage',
        icon: 'NHT',
        requirement: {type: 'boss_no_damage', value: 1},
        reward: 'cosmic_storm',
        unlocked: false
    },
    reach_level_50: {
        id: 'reach_level_50',
        name: 'Legendary Wizard',
        description: 'Reach level 50',
        icon: 'L50',
        requirement: {type: 'level', value: 50},
        reward: 'dragons_fury',
        unlocked: false
    }
};

// Expose ACHIEVEMENTS to window
window.ACHIEVEMENTS = ACHIEVEMENTS;

// Check and unlock achievements
function checkAchievements() {
    Object.values(ACHIEVEMENTS).forEach(achievement => {
        if (achievement.unlocked) return;

        let completed = false;

        switch (achievement.requirement.type) {
            case 'kills':
                completed = gameState.kills >= achievement.requirement.value;
                break;
            case 'time':
                completed = gameState.gameTime >= achievement.requirement.value;
                break;
            case 'level':
                completed = gameState.player.level >= achievement.requirement.value;
                break;
            case 'boss_no_damage':
                // Tracked separately when boss is killed
                break;
        }

        if (completed) {
            achievement.unlocked = true;
            console.log(`ðŸ† ACHIEVEMENT UNLOCKED: ${achievement.name}`);
            console.log(`ðŸŽ You unlocked: ${ULTIMATES[achievement.reward].name} ultimate!`);

            // Show achievement notification (could add UI for this later)
            gameState.lastAchievement = {
                achievement: achievement,
                unlockTime: Date.now()
            };
        }
    });
}

// Game State (expose to window for React UI)
window.gameState = {
    player: {
        x: 0,
        y: 0,
        hp: CONFIG.player.maxHp,
        maxHp: CONFIG.player.maxHp,
        speed: CONFIG.player.speed,
        level: 1,
        xp: 0,
        xpToLevel: 10,
        direction: 'right',
        isMoving: false,
        animationFrame: 0,
        isDashing: false,
        dashCooldown: 0,
        dashDuration: 0,
        dashDx: 0,
        dashDy: 0,
        hasXPMagnet: false, // XP Magnet upgrade
        maxWeapons: 3, // Can have 3 weapons active
        weapons: [ // Start with magic missile
            {
                type: 'magic_missile',
                name: 'Magic Missile',
                damage: 10,
                range: 300,
                cooldown: 500,
                level: 1,
                projectileCount: 1, // For multi-projectile upgrades
                lastFired: 0
            }
        ],
        // Ultimate ability system
        ultimate: {
            type: 'meteor_storm',
            name: 'Meteor Storm',
            icon: 'MTR'
        }, // Start with Meteor Storm for testing
        ultimateCooldown: 0, // Time until ultimate is ready again
        ultimateActive: false // Whether ultimate effect is currently active
    },
    enemies: [],
    projectiles: [],
    particles: [],
    xpOrbs: [],
    chests: [],
    coins: 0,
    orbitingOrbs: [],
    homingMissiles: [],
    tornadoes: [],
    damageNumbers: [], // Floating damage text
    critChance: 0.15, // 15% base crit chance
    critMultiplier: 2.0, // 2x damage on crit
    spinningBlades: [],
    meteors: [],
    chainLightnings: [],
    spiritWolves: [],
    blackHoles: [],
    swordSpinAttack: null,
    keys: {},
    kills: 0,
    gameTime: 0,
    lastSpawn: 0,
    lastAttack: 0,
    isPaused: false,
    isGameOver: false,
    showLevelUp: false,
    showChestPopup: false,
    openingChest: null,
    currentUpgrades: null,
    animationCounter: 0
};

// Load New Wizard Spritesheet
const wizardLPCSprite = new Image();
wizardLPCSprite.src = 'assets/Download62188.png';

// Load Enemy Sprite
const enemySprite = new Image();
enemySprite.src = 'assets/Download67833.png';

// Load Magic Missile Sprite
const magicMissileSprite = new Image();
magicMissileSprite.src = 'assets/MagicMisileGame.png';

// Load Background Texture
const backgroundTexture = new Image();
backgroundTexture.src = 'assets/Background3TestGame.png';

// Load Reward Chest Sprite
const rewardChestSprite = new Image();
rewardChestSprite.src = 'assets/RewardChestGame.png';

// LPC Spritesheet has all animations in one image
const wizardSprites = {
    lpc: wizardLPCSprite
};

// Helper to activate ultimate (defined after gameState)
function activateUltimate() {
    if (!gameState.player.ultimate) {
        console.log('âŒ No ultimate equipped');
        return;
    }
    if (gameState.player.ultimateCooldown > 0) {
        console.log(`âŒ Ultimate on cooldown: ${Math.ceil(gameState.player.ultimateCooldown / 1000)}s remaining`);
        return;
    }
    if (gameState.isPaused || gameState.isGameOver) {
        console.log('âŒ Game is paused or over');
        return;
    }

    const ultimate = ULTIMATES[gameState.player.ultimate.type];
    if (!ultimate) {
        console.log('âŒ Ultimate not found:', gameState.player.ultimate.type);
        return;
    }

    console.log(`ðŸ”¥ Activating ultimate: ${ultimate.name}`);

    // Execute ultimate effect
    ultimate.execute();

    // Set cooldown
    gameState.player.ultimateCooldown = ultimate.cooldown;
}

let spritesReady = false;

wizardLPCSprite.onload = () => {
    console.log('LPC wizard spritesheet loaded!');
    spritesReady = true;
    console.log('Sprites ready. Waiting for player to start game...');
};

wizardLPCSprite.onerror = () => {
    console.error(`Failed to load LPC sprite: ${wizardLPCSprite.src}`);
};

// LPC Wizard sprite config: Each frame is 64x64 pixels
// LPC format: rows are animations for different directions
// Row 9-12 = Walk (up, left, down, right) - 9 frames each
// Row 1-4 = Spellcast (up, left, down, right) - 7 frames each
const wizardConfig = {
    frameWidth: 64,
    frameHeight: 64,
    animations: {
        walk: { frames: 9, speed: 6 },
        idle: { frames: 1, speed: 10 },  // Use first frame of walk as idle
        spellcast: { frames: 7, speed: 5 }
    },
    // LPC row indices for each direction
    rows: {
        up: {
            walk: 8,      // Row 9 (0-indexed = 8)
            spellcast: 0  // Row 1 (0-indexed = 0)
        },
        left: {
            walk: 9,      // Row 10 (0-indexed = 9)
            spellcast: 1  // Row 2 (0-indexed = 1)
        },
        down: {
            walk: 10,     // Row 11 (0-indexed = 10)
            spellcast: 2  // Row 3 (0-indexed = 2)
        },
        right: {
            walk: 11,     // Row 12 (0-indexed = 11)
            spellcast: 3  // Row 4 (0-indexed = 3)
        }
    }
};

// Enemy sprite config (looking at the sprite, appears to be ~64x64 frames)
const enemyConfig = {
    frameWidth: 64,
    frameHeight: 64,
    animations: {
        walk: { frames: 9, speed: 8 }
    },
    rows: {
        up: 8,
        left: 9,
        down: 10,
        right: 11
    }
};

// Canvas and context (will be initialized when DOM is ready)
let canvas, ctx;

// Initialize game when canvas is available
function initGame() {
    canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error('Canvas not found! Retrying...');
        setTimeout(initGame, 100);
        return;
    }

    ctx = canvas.getContext('2d');
    canvas.width = CONFIG.canvas.width;
    canvas.height = CONFIG.canvas.height;

    // Reset game loop timing to prevent jitter on restart
    lastTime = 0;
    frameCount = 0;

    // Reset game state
    gameState.player.hp = gameState.player.maxHp;
    gameState.player.level = 1;
    gameState.player.xp = 0;
    gameState.player.xpToLevel = 20;
    gameState.player.isDashing = false;
    gameState.player.dashCooldown = 0;
    gameState.player.dashDuration = 0;
    gameState.enemies = [];
    gameState.projectiles = [];
    gameState.particles = [];
    gameState.xpOrbs = [];
    gameState.chests = [];
    gameState.homingMissiles = [];
    gameState.tornadoes = [];
    gameState.spinningBlades = [];
    gameState.meteors = [];
    gameState.chainLightnings = [];
    gameState.spiritWolves = [];
    gameState.blackHoles = [];
    gameState.poisonClouds = [];
    gameState.crystalShards = [];
    gameState.frostNovas = [];
    gameState.thunderHammers = [];
    gameState.shadowClones = [];
    gameState.enemyProjectiles = [];
    gameState.kills = 0;
    gameState.gameTime = 0;
    gameState.isGameOver = false;
    gameState.isPaused = false;
    gameState.lastSpawn = 0;
    gameState.lastAttack = 0;

    // Initialize Player Position (center of world)
    gameState.player.x = CONFIG.world.width / 2;
    gameState.player.y = CONFIG.world.height / 2;

    // Initialize camera - center on player immediately to avoid jitter
    camera.x = gameState.player.x - canvas.width / 2;
    camera.y = gameState.player.y - canvas.height / 2;

    // Clamp camera within world bounds from the start
    camera.x = Math.max(0, Math.min(camera.x, CONFIG.world.width - canvas.width));
    camera.y = Math.max(0, Math.min(camera.y, CONFIG.world.height - canvas.height));

    // Handle window resize
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        CONFIG.canvas.width = window.innerWidth;
        CONFIG.canvas.height = window.innerHeight;
    });

    console.log('ðŸŽ® Game initialized! Canvas ready.');
    console.log('Player position:', gameState.player.x, gameState.player.y);
    console.log('Camera position:', camera.x, camera.y);
    console.log('Player weapons:', gameState.player.weapons);

    // Start game loop if not already running
    if (!window.gameLoopRunning) {
        console.log('ðŸš€ Starting game loop...');
        window.gameLoopRunning = true;
        requestAnimationFrame(gameLoop);
    }
}

// Expose initGame globally for React
window.initGame = initGame;

// Input Handling
document.addEventListener('keydown', (e) => {
    // ESC to pause/unpause
    if (e.key === 'Escape') {
        gameState.isPaused = !gameState.isPaused;
        console.log(gameState.isPaused ? 'Game Paused' : 'Game Resumed');
        return;
    }

    // Space to dash (only when game is active)
    if (e.key === ' ' && !gameState.isPaused && !gameState.isGameOver &&
        !gameState.player.isDashing && gameState.player.dashCooldown <= 0) {
        e.preventDefault(); // Prevent page scroll

        // Calculate dash direction based on current movement or facing direction
        let dashDx = 0;
        let dashDy = 0;

        if (gameState.keys['w'] || gameState.keys['arrowup']) {
            dashDy = -1;
        }
        if (gameState.keys['s'] || gameState.keys['arrowdown']) {
            dashDy = 1;
        }
        if (gameState.keys['a'] || gameState.keys['arrowleft']) {
            dashDx = -1;
        }
        if (gameState.keys['d'] || gameState.keys['arrowright']) {
            dashDx = 1;
        }

        // If no keys pressed, dash in facing direction
        if (dashDx === 0 && dashDy === 0) {
            switch(gameState.player.direction) {
                case 'up': dashDy = -1; break;
                case 'down': dashDy = 1; break;
                case 'left': dashDx = -1; break;
                case 'right': dashDx = 1; break;
            }
        }

        // Normalize diagonal dashes
        const dashLength = Math.sqrt(dashDx * dashDx + dashDy * dashDy);
        if (dashLength > 0) {
            dashDx /= dashLength;
            dashDy /= dashLength;
        }

        gameState.player.isDashing = true;
        gameState.player.dashDuration = 200; // 200ms dash
        gameState.player.dashCooldown = 1500; // 1.5 second cooldown
        gameState.player.dashDx = dashDx;
        gameState.player.dashDy = dashDy;

        console.log('ðŸ’¨ Dash!');
        return;
    }

    // R to activate ultimate (only when game is active)
    if ((e.key === 'r' || e.key === 'R') && !gameState.isPaused && !gameState.isGameOver) {
        e.preventDefault();
        activateUltimate();
        return;
    }

    // E to open chest (only when game is active and near a chest)
    if (e.key === 'e' && !gameState.isPaused && !gameState.isGameOver) {
        e.preventDefault();

        // Find nearest chest that player is near
        for (let i = gameState.chests.length - 1; i >= 0; i--) {
            const chest = gameState.chests[i];
            if (chest.isNearPlayer) {
                // Determine chest loot
                const loot = {
                    coins: chest.coinValue,
                    x: chest.x,
                    y: chest.y
                };

                // 5% chance to get an ultimate (very rare!)
                if (Math.random() < 0.05) {
                    // Filter out achievement-only ultimates
                    const chestUltimates = Object.values(ULTIMATES).filter(ult => !ult.achievement);

                    if (chestUltimates.length > 0) {
                        const randomUltimate = chestUltimates[Math.floor(Math.random() * chestUltimates.length)];

                        loot.ultimate = {
                            type: randomUltimate.type,
                            name: randomUltimate.name,
                            icon: randomUltimate.icon,
                            description: randomUltimate.description
                        };

                        console.log(`ðŸŽ RARE ULTIMATE FOUND: ${randomUltimate.name}`);
                    }
                }

                // Store chest data and remove it from world
                gameState.openingChest = loot;
                gameState.chests.splice(i, 1);
                gameState.isPaused = true; // Pause game to show chest UI
                console.log(`Opening chest with ${chest.coinValue} coins!`);
                break;
            }
        }

        // Check for mystery boxes
        if (gameState.mysteryBoxes) {
            for (let i = gameState.mysteryBoxes.length - 1; i >= 0; i--) {
                const box = gameState.mysteryBoxes[i];
                if (box.isNearPlayer) {
                    // Open mystery box spinner (free spin from drop!)
                    gameState.openingMysteryBox = { free: true }; // Mark as free spin
                    gameState.mysteryBoxes.splice(i, 1);
                    gameState.isPaused = true; // Pause game to show spinner
                    console.log('Opening Mystery Box!');
                    break;
                }
            }
        }

        return;
    }

    gameState.keys[e.key.toLowerCase()] = true;
});

document.addEventListener('keyup', (e) => {
    gameState.keys[e.key.toLowerCase()] = false;
});

// Player Class with Animation
class Player {
    constructor() {
        this.x = gameState.player.x;
        this.y = gameState.player.y;
    }

    update() {
        // Handle dash
        if (gameState.player.isDashing) {
            const dashSpeed = 12; // Fast dash speed

            gameState.player.x = Math.max(CONFIG.player.size, Math.min(CONFIG.world.width - CONFIG.player.size,
                gameState.player.x + gameState.player.dashDx * dashSpeed));
            gameState.player.y = Math.max(CONFIG.player.size, Math.min(CONFIG.world.height - CONFIG.player.size,
                gameState.player.y + gameState.player.dashDy * dashSpeed));

            // Create dash trail particles
            for (let i = 0; i < 3; i++) {
                gameState.particles.push({
                    x: gameState.player.x + (Math.random() - 0.5) * 20,
                    y: gameState.player.y + (Math.random() - 0.5) * 20,
                    vx: -gameState.player.dashDx * 2 + (Math.random() - 0.5) * 2,
                    vy: -gameState.player.dashDy * 2 + (Math.random() - 0.5) * 2,
                    size: 4 + Math.random() * 4,
                    color: '#00ffff',
                    alpha: 0.8,
                    decay: 0.05,
                    lifetime: 20
                });
            }

            gameState.player.dashDuration -= 16; // Subtract ~16ms per frame
            if (gameState.player.dashDuration <= 0) {
                gameState.player.isDashing = false;
            }
            return; // Skip normal movement during dash
        }

        // Update dash cooldown
        if (gameState.player.dashCooldown > 0) {
            gameState.player.dashCooldown -= 16; // Subtract ~16ms per frame
            if (gameState.player.dashCooldown < 0) {
                gameState.player.dashCooldown = 0;
            }
        }

        const speed = gameState.player.speed;
        let moving = false;
        let verticalDir = null;

        // Movement with 4-directional sprite support (bounded by WORLD, not canvas)
        if (gameState.keys['w'] || gameState.keys['arrowup']) {
            gameState.player.y = Math.max(CONFIG.player.size, gameState.player.y - speed);
            gameState.player.direction = 'up';
            verticalDir = 'up';
            moving = true;
        }
        if (gameState.keys['s'] || gameState.keys['arrowdown']) {
            gameState.player.y = Math.min(CONFIG.world.height - CONFIG.player.size, gameState.player.y + speed);
            gameState.player.direction = 'down';
            verticalDir = 'down';
            moving = true;
        }
        if (gameState.keys['a'] || gameState.keys['arrowleft']) {
            gameState.player.x = Math.max(CONFIG.player.size, gameState.player.x - speed);
            gameState.player.direction = 'left';
            moving = true;
        }
        if (gameState.keys['d'] || gameState.keys['arrowright']) {
            gameState.player.x = Math.min(CONFIG.world.width - CONFIG.player.size, gameState.player.x + speed);
            gameState.player.direction = 'right';
            moving = true;
        }

        gameState.player.isMoving = moving;

        // Update animation frame (slower for smoother animation)
        if (moving) {
            gameState.animationCounter++;
            if (gameState.animationCounter % 6 === 0) {  // Changed from 8 to 6 for smoother animation
                gameState.player.animationFrame++;
            }
        } else {
            gameState.animationCounter++;
            if (gameState.animationCounter % 10 === 0) {  // Idle animation is slower
                gameState.player.animationFrame++;
            }
        }
    }

    drawCharacter() {
        // Check if LPC sprite is loaded
        if (!wizardLPCSprite.complete || wizardLPCSprite.naturalWidth === 0) {
            // Draw a fallback circle if sprite not loaded
            const screenX = gameState.player.x - camera.x;
            const screenY = gameState.player.y - camera.y;
            ctx.fillStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
            ctx.fill();
            return;
        }

        // Get direction (default to 'down' if not set)
        const direction = gameState.player.direction || 'down';

        // Choose animation type
        const animationType = gameState.player.isMoving ? 'walk' : 'walk'; // Use walk for both, idle uses frame 0
        const animation = wizardConfig.animations[animationType];

        // Get the correct row for this direction
        const row = wizardConfig.rows[direction][animationType];

        // Calculate frame
        let frame;
        if (gameState.player.isMoving) {
            frame = gameState.player.animationFrame % animation.frames;
        } else {
            frame = 0; // Idle uses first frame of walk
        }

        // Calculate source position in spritesheet
        const srcX = frame * wizardConfig.frameWidth;
        const srcY = row * wizardConfig.frameHeight;

        // Scale for character (64x64 -> 64x64)
        const scale = 1.0;
        const drawWidth = wizardConfig.frameWidth * scale;
        const drawHeight = wizardConfig.frameHeight * scale;

        // Convert world position to screen position
        const screenX = gameState.player.x - camera.x;
        const screenY = gameState.player.y - camera.y;

        ctx.save();

        // Dash visual effect (glow and afterimage)
        if (gameState.player.isDashing) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.globalAlpha = 0.9;
        }

        // Damage flash effect - blink white when taking damage
        if (gameState.playerDamageFlash) {
            const elapsed = (gameState.currentTime || 0) - gameState.playerDamageFlash.startTime;
            if (elapsed < gameState.playerDamageFlash.duration) {
                // Blink on/off every blinkInterval
                const blinkCycle = Math.floor(elapsed / gameState.playerDamageFlash.blinkInterval);
                if (blinkCycle % 2 === 0) {
                    // Flash white
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.filter = 'brightness(2.5)'; // Make very bright
                }
            } else {
                gameState.playerDamageFlash = null;
            }
        }

        // Draw the sprite (no rotation needed - LPC has proper directional sprites!)
        ctx.drawImage(
            wizardLPCSprite,
            srcX, srcY,
            wizardConfig.frameWidth, wizardConfig.frameHeight,
            screenX - drawWidth / 2,
            screenY - drawHeight / 2,
            drawWidth, drawHeight
        );

        ctx.restore();
    }

    draw() {
        this.drawCharacter();
        // Removed weapon range indicator circle
    }

    takeDamage(amount) {
        gameState.player.hp -= amount;

        // Screen shake
        gameState.screenShake = {
            intensity: Math.min(amount * 1.2, 12), // Stronger shake (max 12px)
            duration: 250, // 250ms shake
            startTime: gameState.currentTime || 0
        };

        // Player damage flash - blink white/red
        gameState.playerDamageFlash = {
            startTime: gameState.currentTime || 0,
            duration: 400, // Blink for 400ms
            blinkInterval: 50 // Blink every 50ms
        };

        // Red vignette effect
        gameState.damageVignette = {
            startTime: gameState.currentTime || 0,
            duration: 300,
            intensity: Math.min(amount / 20, 0.6) // Scale with damage
        };

        // Create blood particles - very small and few
        const particleCount = Math.min(Math.floor(amount / 4) + 2, 5); // Very few particles (2-5)
        console.log(`ðŸ’¥ Taking ${amount} damage! Shake intensity: ${gameState.screenShake.intensity}, Blood particles: ${particleCount}`);
        for (let i = 0; i < particleCount; i++) {
            const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
            const speed = 1 + Math.random() * 1.5; // Even slower
            const size = 1.5 + Math.random() * 1.5; // Very small (1.5-3px)

            gameState.particles.push({
                x: gameState.player.x,
                y: gameState.player.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 1, // Initial upward velocity
                size: size,
                alpha: 1.0,
                decay: 0.015 + Math.random() * 0.01,
                lifetime: 60 + Math.floor(Math.random() * 30), // 60-90 frames
                color: Math.random() > 0.5 ? '#8b0000' : '#ff0000', // Dark red or bright red
                gravity: 0.15
            });
        }

        if (gameState.player.hp <= 0) {
            gameOver();
        }
    }
}

// Enemy Class
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size;

        // Apply difficulty scaling
        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * difficulty.speed;
        this.baseHp = 15;
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 10;
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0; // For ice effect
        this.difficultyTier = difficulty.intervals; // Track which tier this enemy is

        // Animation properties
        this.direction = 'down';
        this.animationFrame = 0;
        this.animationCounter = 0;

        // Death explosion color palette (green for goblin)
        this.colorPalette = ['#4a9d5f', '#5fb571', '#6ed47f', '#3d8a4f', '#7be58d'];
    }

    update() {
        // Move towards player
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Apply slow effect
        const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

        if (distance > 0) {
            this.x += (dx / distance) * currentSpeed;
            this.y += (dy / distance) * currentSpeed;

            // Update direction based on movement
            const absX = Math.abs(dx);
            const absY = Math.abs(dy);
            if (absX > absY) {
                this.direction = dx > 0 ? 'right' : 'left';
            } else {
                this.direction = dy > 0 ? 'down' : 'up';
            }

            // Update animation
            this.animationCounter++;
            if (this.animationCounter >= enemyConfig.animations.walk.speed) {
                this.animationCounter = 0;
                this.animationFrame = (this.animationFrame + 1) % enemyConfig.animations.walk.frames;
            }
        }

        // Check collision with player
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.016); // Damage per frame
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const isSlowed = Date.now() < this.slowedUntil;

        // Draw sprite if loaded, otherwise fallback
        if (enemySprite.complete && enemySprite.naturalWidth > 0) {
            const row = enemyConfig.rows[this.direction];
            const srcX = this.animationFrame * enemyConfig.frameWidth;
            const srcY = row * enemyConfig.frameHeight;

            const scale = 1.0;
            const drawWidth = enemyConfig.frameWidth * scale;
            const drawHeight = enemyConfig.frameHeight * scale;

            // Apply ice tint if slowed
            if (isSlowed) {
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.filter = 'hue-rotate(180deg) brightness(1.2)';
            }

            ctx.drawImage(
                enemySprite,
                srcX, srcY,
                enemyConfig.frameWidth, enemyConfig.frameHeight,
                screen.x - drawWidth / 2,
                screen.y - drawHeight / 2,
                drawWidth, drawHeight
            );

            if (isSlowed) {
                ctx.restore();

                // Ice effect overlay
                const time = Date.now() * 0.003;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, this.size + 4, 0, Math.PI * 2);
                ctx.stroke();

                // Ice crystals
                for (let i = 0; i < 6; i++) {
                    const iceAngle = (Math.PI * 2 / 6) * i + time;
                    const iceX = screen.x + Math.cos(iceAngle) * (this.size + 6);
                    const iceY = screen.y + Math.sin(iceAngle) * (this.size + 6);
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.fillRect(iceX - 2, iceY - 2, 4, 4);
                }
            }
        } else {
            // Fallback circle
            ctx.fillStyle = isSlowed ? '#4a5f8a' : '#2d4a3e';
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw health bar
        const barWidth = 30;
        const barHeight = 4;
        const healthPercent = this.hp / this.maxHp;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 10, barWidth, barHeight);

        ctx.fillStyle = '#e94560';
        ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 10, barWidth * healthPercent, barHeight);
    }

    adjustColorForTier(hexColor, intensity, brighten = false) {
        // Convert hex to RGB
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);

        // Adjust color based on tier (darker for body, brighter for eyes)
        let newR, newG, newB;
        if (brighten) {
            newR = Math.min(255, r + (255 - r) * intensity);
            newG = Math.min(255, g + (255 - g) * intensity);
            newB = Math.min(255, b + (255 - b) * intensity);
        } else {
            newR = Math.max(0, r - r * intensity);
            newG = Math.max(0, g - g * intensity);
            newB = Math.max(0, b - b * intensity);
        }

        return `rgb(${Math.floor(newR)}, ${Math.floor(newG)}, ${Math.floor(newB)})`;
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Charger Enemy Class - Rushes at player then rests
class ChargerEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size + 5; // Slightly bigger

        // Apply difficulty scaling
        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * 2.5 * difficulty.speed; // Much faster
        this.baseHp = 50;
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 15;
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Charger behavior
        this.state = 'idle'; // idle, charging, resting
        this.idleTime = 1000; // Wait 1 second before charging
        this.chargeTime = 1500; // Charge for 1.5 seconds
        this.restTime = 2000; // Rest for 2 seconds
        this.stateStartTime = Date.now();

        // Store charge direction
        this.chargeAngle = 0;
        this.chargeDx = 0;
        this.chargeDy = 0;
    }

    update() {
        const currentTime = Date.now();
        const timeSinceStateStart = currentTime - this.stateStartTime;

        // State machine
        if (this.state === 'idle') {
            if (timeSinceStateStart > this.idleTime) {
                // Start charging - calculate direction to player
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    this.chargeDx = dx / distance;
                    this.chargeDy = dy / distance;
                    this.chargeAngle = Math.atan2(dy, dx);
                }

                this.state = 'charging';
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'charging') {
            // Rush towards stored direction
            const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

            this.x += this.chargeDx * currentSpeed;
            this.y += this.chargeDy * currentSpeed;

            if (timeSinceStateStart > this.chargeTime) {
                this.state = 'resting';
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'resting') {
            // Stand still and catch breath
            if (timeSinceStateStart > this.restTime) {
                this.state = 'idle';
                this.stateStartTime = currentTime;
            }
        }

        // Check collision with player
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.016);
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const isSlowed = Date.now() < this.slowedUntil;

        // Different colors based on state
        let bodyColor, darkColor, eyeGlow;

        if (this.state === 'charging') {
            // Red angry colors when charging
            bodyColor = isSlowed ? '#7a4f5f' : '#8b2f3f';
            darkColor = isSlowed ? '#5a2f3f' : '#5a1f2a';
            eyeGlow = isSlowed ? '#00ffff' : '#ffff00'; // Yellow eyes when charging
        } else if (this.state === 'resting') {
            // Dark tired colors when resting
            bodyColor = isSlowed ? '#3a4f5a' : '#2a3540';
            darkColor = isSlowed ? '#2a3f4a' : '#1a2530';
            eyeGlow = isSlowed ? '#00ffff' : '#6666ff';
        } else {
            // Normal colors when idle
            bodyColor = isSlowed ? '#5a4f6a' : '#4a3555';
            darkColor = isSlowed ? '#3a2f4a' : '#2a1f35';
            eyeGlow = isSlowed ? '#00ffff' : '#ff6633';
        }

        // Draw monster body (more rectangular/bulky shape for charger)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        const time = Date.now() * 0.005;

        if (this.state === 'charging') {
            // Elongated shape when charging
            const wobble = Math.sin(time * 3) * 1;
            ctx.ellipse(screen.x, screen.y + 2, this.size + 3, this.size - 5 + wobble, this.chargeAngle, 0, Math.PI * 2);
        } else if (this.state === 'resting') {
            // Squished shape when resting (tired)
            ctx.ellipse(screen.x, screen.y + 4, this.size - 2, this.size - 6, 0, 0, Math.PI * 2);
        } else {
            // Normal shape when idle
            ctx.ellipse(screen.x, screen.y + 2, this.size, this.size - 3, 0, 0, Math.PI * 2);
        }
        ctx.fill();

        // Draw darker bottom shadow
        ctx.fillStyle = darkColor;
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y + 6, this.size - 6, this.size - 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // Draw horns
        ctx.fillStyle = darkColor;
        const hornOffset = this.size * 0.5;
        ctx.beginPath();
        ctx.moveTo(screen.x - hornOffset, screen.y - this.size * 0.3);
        ctx.lineTo(screen.x - hornOffset - 8, screen.y - this.size * 0.8);
        ctx.lineTo(screen.x - hornOffset + 3, screen.y - this.size * 0.3);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(screen.x + hornOffset, screen.y - this.size * 0.3);
        ctx.lineTo(screen.x + hornOffset + 8, screen.y - this.size * 0.8);
        ctx.lineTo(screen.x + hornOffset - 3, screen.y - this.size * 0.3);
        ctx.fill();

        // Draw monster eyes
        const eyeOffset = this.size * 0.25;
        const eyeSize = this.size * 0.15;

        // White part of eyes
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(screen.x - eyeOffset, screen.y, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(screen.x + eyeOffset, screen.y, eyeSize, 0, Math.PI * 2);
        ctx.fill();

        // Pupils
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const angle = Math.atan2(dy, dx);
        const pupilDist = eyeSize * 0.3;
        const pupilX = Math.cos(angle) * pupilDist;
        const pupilY = Math.sin(angle) * pupilDist;

        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(screen.x - eyeOffset + pupilX, screen.y + pupilY, eyeSize * 0.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(screen.x + eyeOffset + pupilX, screen.y + pupilY, eyeSize * 0.7, 0, Math.PI * 2);
        ctx.fill();

        // Eye glow effect (stronger when charging)
        const glowStrength = this.state === 'charging' ? 12 : 6;
        ctx.shadowBlur = glowStrength;
        ctx.shadowColor = eyeGlow;
        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(screen.x - eyeOffset + pupilX, screen.y + pupilY, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(screen.x + eyeOffset + pupilX, screen.y + pupilY, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw mouth (grimacing)
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y + 6, this.size * 0.35, this.size * 0.2, 0, 0, Math.PI);
        ctx.fill();

        // Teeth (more than normal enemy)
        ctx.fillStyle = '#ffffff';
        const teeth = 6;
        for (let i = 0; i < teeth; i++) {
            const tx = screen.x - this.size * 0.28 + (this.size * 0.56 / (teeth - 1)) * i;
            ctx.beginPath();
            ctx.moveTo(tx, screen.y + 6);
            ctx.lineTo(tx - 2, screen.y + 10);
            ctx.lineTo(tx + 2, screen.y + 10);
            ctx.closePath();
            ctx.fill();
        }

        // Charge effect (speed lines)
        if (this.state === 'charging' && !isSlowed) {
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const lineAngle = this.chargeAngle + Math.PI;
                const lineLength = 15 + i * 10;
                const startX = screen.x + Math.cos(lineAngle) * (this.size + 5);
                const startY = screen.y + Math.sin(lineAngle) * (this.size + 5);
                const endX = startX + Math.cos(lineAngle) * lineLength;
                const endY = startY + Math.sin(lineAngle) * lineLength;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }

        // Resting effect (zzz)
        if (this.state === 'resting') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '12px Arial';
            const zOffset = Math.sin(time * 2) * 3;
            ctx.fillText('z', screen.x + this.size * 0.5, screen.y - this.size - 10 + zOffset);
            ctx.fillText('Z', screen.x + this.size * 0.6 + 5, screen.y - this.size - 15 + zOffset);
        }

        // Ice effect overlay
        if (isSlowed) {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.size + 4, 0, Math.PI * 2);
            ctx.stroke();

            // Ice crystals
            for (let i = 0; i < 6; i++) {
                const iceAngle = (Math.PI * 2 / 6) * i + time;
                const iceX = screen.x + Math.cos(iceAngle) * (this.size + 6);
                const iceY = screen.y + Math.sin(iceAngle) * (this.size + 6);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.fillRect(iceX - 2, iceY - 2, 4, 4);
            }
        }

        // Draw health bar
        const barWidth = 35;
        const barHeight = 5;
        const healthPercent = this.hp / this.maxHp;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 15, barWidth, barHeight);

        ctx.fillStyle = '#e94560';
        ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 15, barWidth * healthPercent, barHeight);
    }

    adjustColorForTier(hexColor, intensity, brighten = false) {
        // Convert hex to RGB
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);

        // Adjust color based on tier (darker for body, brighter for eyes)
        let newR, newG, newB;
        if (brighten) {
            newR = Math.min(255, r + (255 - r) * intensity);
            newG = Math.min(255, g + (255 - g) * intensity);
            newB = Math.min(255, b + (255 - b) * intensity);
        } else {
            newR = Math.max(0, r - r * intensity);
            newG = Math.max(0, g - g * intensity);
            newB = Math.max(0, b - b * intensity);
        }

        return `rgb(${Math.floor(newR)}, ${Math.floor(newG)}, ${Math.floor(newB)})`;
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Teleporter Enemy Class - Teleports around player and shoots projectiles
class TeleporterEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size + 3;

        // Apply difficulty scaling
        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * 0.5 * difficulty.speed; // Slower when walking
        this.baseHp = 40;
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 8;
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Teleporter behavior
        this.state = 'idle'; // idle, preparing, teleporting, attacking
        this.idleTime = 2000; // Wait 2 seconds
        this.prepareTime = 1000; // Prepare to teleport for 1 second
        this.attackTime = 1500; // Attack for 1.5 seconds
        this.stateStartTime = Date.now();

        // Teleport properties
        this.teleportCooldown = 0;
        this.teleportX = x;
        this.teleportY = y;
        this.isTeleporting = false;
        this.teleportProgress = 0;
        this.lastTeleportX = x;
        this.lastTeleportY = y;

        // Attack properties
        this.lastAttackTime = 0;
        this.attackCooldown = 800; // Shoot every 0.8 seconds
        this.projectiles = []; // Store enemy projectiles

        // Death explosion color palette (purple for teleporter)
        this.colorPalette = ['#8b5cf6', '#a78bfa', '#c4b5fd', '#7c3aed', '#ddd6fe'];
    }

    update() {
        const currentTime = Date.now();
        const timeSinceStateStart = currentTime - this.stateStartTime;

        // State machine
        if (this.state === 'idle') {
            // Slowly move towards player
            const dx = gameState.player.x - this.x;
            const dy = gameState.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;
                this.x += (dx / distance) * currentSpeed;
                this.y += (dy / distance) * currentSpeed;
            }

            if (timeSinceStateStart > this.idleTime) {
                this.state = 'preparing';
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'preparing') {
            // Stand still and charge up teleport
            if (timeSinceStateStart > this.prepareTime) {
                // Choose teleport location (around player at medium distance)
                const angle = Math.random() * Math.PI * 2;
                const distance = 150 + Math.random() * 100; // 150-250 pixels from player

                this.lastTeleportX = this.x;
                this.lastTeleportY = this.y;
                this.teleportX = gameState.player.x + Math.cos(angle) * distance;
                this.teleportY = gameState.player.y + Math.sin(angle) * distance;

                // Clamp to world bounds
                this.teleportX = Math.max(this.size, Math.min(CONFIG.world.width - this.size, this.teleportX));
                this.teleportY = Math.max(this.size, Math.min(CONFIG.world.height - this.size, this.teleportY));

                this.state = 'teleporting';
                this.isTeleporting = true;
                this.teleportProgress = 0;
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'teleporting') {
            // Animate teleport
            this.teleportProgress += 0.1;

            if (this.teleportProgress >= 1) {
                this.x = this.teleportX;
                this.y = this.teleportY;
                this.isTeleporting = false;
                this.state = 'attacking';
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'attacking') {
            // Stand still and shoot projectiles at player
            if (currentTime - this.lastAttackTime > this.attackCooldown) {
                this.shootAtPlayer();
                this.lastAttackTime = currentTime;
            }

            if (timeSinceStateStart > this.attackTime) {
                this.state = 'idle';
                this.stateStartTime = currentTime;
            }
        }

        // Update projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.x += proj.vx;
            proj.y += proj.vy;
            proj.lifetime--;

            // Check collision with player
            const playerDist = Math.sqrt(
                Math.pow(proj.x - gameState.player.x, 2) +
                Math.pow(proj.y - gameState.player.y, 2)
            );

            if (playerDist < CONFIG.player.size + proj.size) {
                player.takeDamage(this.damage);
                this.projectiles.splice(i, 1);
                createParticles(proj.x, proj.y, '#9400d3');
            } else if (proj.lifetime <= 0) {
                this.projectiles.splice(i, 1);
            }
        }

        // Check collision with player (contact damage)
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.01);
        }
    }

    shootAtPlayer() {
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 0) {
            const speed = 3;
            this.projectiles.push({
                x: this.x,
                y: this.y,
                vx: (dx / distance) * speed,
                vy: (dy / distance) * speed,
                size: 6,
                lifetime: 180 // 3 seconds at 60fps
            });
        }
    }

    draw() {
        // Draw projectiles first (behind enemy)
        this.projectiles.forEach(proj => {
            const screen = toScreen(proj.x, proj.y);

            ctx.shadowBlur = 10;
            ctx.shadowColor = '#9400d3';
            ctx.fillStyle = '#9400d3';
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, proj.size, 0, Math.PI * 2);
            ctx.fill();

            // Inner glow
            ctx.fillStyle = '#da70d6';
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, proj.size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });

        // Teleport effect
        if (this.isTeleporting) {
            // Draw fading out at old position
            const oldScreen = toScreen(this.lastTeleportX, this.lastTeleportY);
            ctx.globalAlpha = 1 - this.teleportProgress;
            this.drawBody(oldScreen.x, oldScreen.y, true);
            ctx.globalAlpha = 1;

            // Draw fading in at new position
            const newScreen = toScreen(this.teleportX, this.teleportY);
            ctx.globalAlpha = this.teleportProgress;
            this.drawBody(newScreen.x, newScreen.y, true);
            ctx.globalAlpha = 1;
        } else {
            const screen = toScreen(this.x, this.y);
            this.drawBody(screen.x, screen.y, false);
        }
    }

    drawBody(screenX, screenY, isTeleporting) {
        const isSlowed = Date.now() < this.slowedUntil;
        const time = Date.now() * 0.003;

        // Different colors based on state
        let bodyColor, darkColor, eyeGlow;

        if (this.state === 'preparing' || isTeleporting) {
            // Purple glow when preparing/teleporting
            bodyColor = '#6a0dad';
            darkColor = '#4b0082';
            eyeGlow = '#da70d6';
        } else if (this.state === 'attacking') {
            // Bright purple when attacking
            bodyColor = '#8b00ff';
            darkColor = '#6a0dad';
            eyeGlow = '#ff00ff';
        } else {
            // Dark purple when idle
            bodyColor = isSlowed ? '#5a4f6a' : '#4b0082';
            darkColor = isSlowed ? '#3a2f4a' : '#2e0854';
            eyeGlow = isSlowed ? '#00ffff' : '#9400d3';
        }

        // Teleport particles around body
        if (this.state === 'preparing' || isTeleporting) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i + time * 2;
                const radius = this.size + 8 + Math.sin(time * 3 + i) * 4;
                const px = screenX + Math.cos(angle) * radius;
                const py = screenY + Math.sin(angle) * radius;

                ctx.fillStyle = '#da70d6';
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw glowing aura
        ctx.shadowBlur = this.state === 'preparing' || isTeleporting ? 20 : 10;
        ctx.shadowColor = bodyColor;

        // Draw monster body (floating orb-like shape)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        const wobble = Math.sin(time * 2) * 2;
        ctx.ellipse(screenX, screenY, this.size + wobble, this.size - wobble, 0, 0, Math.PI * 2);
        ctx.fill();

        // Draw darker inner core
        ctx.fillStyle = darkColor;
        ctx.beginPath();
        ctx.ellipse(screenX, screenY, this.size - 5, this.size - 5, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;

        // Draw energy rings around body
        ctx.strokeStyle = eyeGlow;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < 2; i++) {
            const ringTime = time + i * Math.PI;
            const ringSize = this.size + 10 + Math.sin(ringTime) * 5;
            ctx.beginPath();
            ctx.arc(screenX, screenY, ringSize, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;

        // Draw single large eye in center
        const eyeSize = this.size * 0.4;

        // White part
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(screenX, screenY, eyeSize, 0, Math.PI * 2);
        ctx.fill();

        // Pupil tracking player
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const angle = Math.atan2(dy, dx);
        const pupilDist = eyeSize * 0.3;
        const pupilX = Math.cos(angle) * pupilDist;
        const pupilY = Math.sin(angle) * pupilDist;

        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(screenX + pupilX, screenY + pupilY, eyeSize * 0.7, 0, Math.PI * 2);
        ctx.fill();

        // Bright center glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = eyeGlow;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(screenX + pupilX, screenY + pupilY, eyeSize * 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Ice effect overlay
        if (isSlowed && !isTeleporting) {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(screenX, screenY, this.size + 4, 0, Math.PI * 2);
            ctx.stroke();

            // Ice crystals
            for (let i = 0; i < 6; i++) {
                const iceAngle = (Math.PI * 2 / 6) * i + time;
                const iceX = screenX + Math.cos(iceAngle) * (this.size + 6);
                const iceY = screenY + Math.sin(iceAngle) * (this.size + 6);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.fillRect(iceX - 2, iceY - 2, 4, 4);
            }
        }

        // Draw health bar (only when not teleporting)
        if (!isTeleporting) {
            const barWidth = 35;
            const barHeight = 4;
            const healthPercent = this.hp / this.maxHp;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(screenX - barWidth / 2, screenY - this.size - 15, barWidth, barHeight);

            ctx.fillStyle = '#9400d3';
            ctx.fillRect(screenX - barWidth / 2, screenY - this.size - 15, barWidth * healthPercent, barHeight);
        }
    }

    adjustColorForTier(hexColor, intensity, brighten = false) {
        // Convert hex to RGB
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);

        // Adjust color based on tier (darker for body, brighter for eyes)
        let newR, newG, newB;
        if (brighten) {
            newR = Math.min(255, r + (255 - r) * intensity);
            newG = Math.min(255, g + (255 - g) * intensity);
            newB = Math.min(255, b + (255 - b) * intensity);
        } else {
            newR = Math.max(0, r - r * intensity);
            newG = Math.max(0, g - g * intensity);
            newB = Math.max(0, b - b * intensity);
        }

        return `rgb(${Math.floor(newR)}, ${Math.floor(newG)}, ${Math.floor(newB)})`;
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Necromancer Miniboss Class - Powerful boss that summons enemies and casts spells
class NecromancerBoss {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 40; // Much larger than normal enemies
        this.speed = CONFIG.enemy.speed * 0.3; // Very slow
        this.hp = 500; // Boss HP
        this.maxHp = 500;
        this.damage = 20;
        this.slowedUntil = 0;
        this.isBoss = true;

        // Boss behavior
        this.state = 'floating'; // floating, summoning, casting, channeling
        this.floatTime = 3000; // Float for 3 seconds
        this.summonTime = 2000; // Summon for 2 seconds
        this.castTime = 1500; // Cast for 1.5 seconds
        this.channelingTime = 2500; // Channel beam for 2.5 seconds
        this.stateStartTime = Date.now();

        // Attack properties
        this.projectiles = [];
        this.lastProjectileTime = 0;
        this.projectileCooldown = 400;

        // Summoning properties
        this.summonedEnemies = [];
        this.maxSummons = 8;

        // Beam attack
        this.beamActive = false;
        this.beamAngle = 0;
        this.beamRotationSpeed = 0.02;
        this.beamDamage = 0.5; // Damage per frame
        this.beamRange = 250;

        // Visual effects
        this.floatOffset = 0;
        this.auraRotation = 0;
        this.particles = [];

        // Shield
        this.hasShield = true;
        this.shieldHp = 100;
        this.maxShieldHp = 100;
        this.shieldRegenCooldown = 0;
        this.shieldRegenDelay = 5000; // 5 seconds before shield starts regenerating

        // Death explosion color palette (dark purple/black for necromancer)
        this.colorPalette = ['#4c1d95', '#6b21a8', '#7e22ce', '#2e1065', '#9333ea'];
    }

    update() {
        const currentTime = Date.now();
        const timeSinceStateStart = currentTime - this.stateStartTime;

        // Update visual effects
        this.floatOffset = Math.sin(currentTime * 0.002) * 10;
        this.auraRotation += 0.01;

        // Shield regeneration
        if (this.shieldHp < this.maxShieldHp && this.shieldRegenCooldown <= 0) {
            this.shieldHp = Math.min(this.maxShieldHp, this.shieldHp + 0.2);
        }
        if (this.shieldRegenCooldown > 0) {
            this.shieldRegenCooldown -= 16;
        }

        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.02;
            p.size *= 0.98;

            if (p.alpha <= 0 || p.size < 0.5) {
                this.particles.splice(i, 1);
            }
        }

        // State machine
        if (this.state === 'floating') {
            // Slowly circle around player
            const dx = gameState.player.x - this.x;
            const dy = gameState.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Maintain distance of 200-300 pixels
            const targetDistance = 250;
            if (distance > 0) {
                const angle = Math.atan2(dy, dx);
                const perpAngle = angle + Math.PI / 2;

                let moveX = 0, moveY = 0;

                if (distance > targetDistance + 50) {
                    moveX = (dx / distance) * this.speed;
                    moveY = (dy / distance) * this.speed;
                } else if (distance < targetDistance - 50) {
                    moveX = -(dx / distance) * this.speed;
                    moveY = -(dy / distance) * this.speed;
                }

                // Add circular movement
                moveX += Math.cos(perpAngle) * this.speed;
                moveY += Math.sin(perpAngle) * this.speed;

                this.x += moveX;
                this.y += moveY;
            }

            // Shoot projectiles
            if (currentTime - this.lastProjectileTime > this.projectileCooldown) {
                this.shootSpiral();
                this.lastProjectileTime = currentTime;
            }

            if (timeSinceStateStart > this.floatTime) {
                // Choose next attack
                const roll = Math.random();
                if (roll < 0.4 && this.summonedEnemies.length < this.maxSummons) {
                    this.state = 'summoning';
                } else if (roll < 0.7) {
                    this.state = 'casting';
                } else {
                    this.state = 'channeling';
                    this.beamActive = true;
                    this.beamAngle = Math.atan2(
                        gameState.player.y - this.y,
                        gameState.player.x - this.x
                    );
                }
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'summoning') {
            // Summon enemies around the boss
            if (timeSinceStateStart > this.summonTime) {
                this.summonEnemies();
                this.state = 'floating';
                this.stateStartTime = currentTime;
            }

            // Create summoning particles
            if (Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 20;
                this.particles.push({
                    x: this.x + Math.cos(angle) * dist,
                    y: this.y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * -2,
                    vy: Math.sin(angle) * -2,
                    size: 4 + Math.random() * 4,
                    alpha: 1,
                    color: '#00ff00'
                });
            }
        } else if (this.state === 'casting') {
            // Fire spread of projectiles
            if (timeSinceStateStart > this.castTime) {
                this.castSpreadAttack();
                this.state = 'floating';
                this.stateStartTime = currentTime;
            }
        } else if (this.state === 'channeling') {
            // Rotate beam attack
            this.beamAngle += this.beamRotationSpeed;

            // Check if beam hits player
            const beamEndX = this.x + Math.cos(this.beamAngle) * this.beamRange;
            const beamEndY = this.y + Math.sin(this.beamAngle) * this.beamRange;

            // Simple line-circle collision
            const playerDist = Math.sqrt(
                Math.pow(gameState.player.x - this.x, 2) +
                Math.pow(gameState.player.y - this.y, 2)
            );

            if (playerDist < this.beamRange) {
                const angleToPlayer = Math.atan2(
                    gameState.player.y - this.y,
                    gameState.player.x - this.x
                );
                const angleDiff = Math.abs(this.beamAngle - angleToPlayer);

                if (angleDiff < 0.2 || angleDiff > Math.PI * 2 - 0.2) {
                    player.takeDamage(this.beamDamage);

                    // Beam hit particles
                    if (Math.random() < 0.5) {
                        createParticles(gameState.player.x, gameState.player.y, '#ff0000');
                    }
                }
            }

            if (timeSinceStateStart > this.channelingTime) {
                this.beamActive = false;
                this.state = 'floating';
                this.stateStartTime = currentTime;
            }
        }

        // Update projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.x += proj.vx;
            proj.y += proj.vy;
            proj.lifetime--;

            // Check collision with player
            const playerDist = Math.sqrt(
                Math.pow(proj.x - gameState.player.x, 2) +
                Math.pow(proj.y - gameState.player.y, 2)
            );

            if (playerDist < CONFIG.player.size + proj.size) {
                player.takeDamage(this.damage);
                this.projectiles.splice(i, 1);
                createParticles(proj.x, proj.y, proj.color);
            } else if (proj.lifetime <= 0) {
                this.projectiles.splice(i, 1);
            }
        }

        // Check collision with player (contact damage)
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.015);
        }

        // Remove dead summoned enemies from tracking
        this.summonedEnemies = this.summonedEnemies.filter(e =>
            gameState.enemies.includes(e)
        );
    }

    shootSpiral() {
        // Shoot 3 projectiles in a spiral pattern
        const baseAngle = Math.atan2(
            gameState.player.y - this.y,
            gameState.player.x - this.x
        );

        for (let i = 0; i < 3; i++) {
            const angle = baseAngle + (i - 1) * 0.3;
            const speed = 2.5;

            this.projectiles.push({
                x: this.x,
                y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 8,
                lifetime: 200,
                color: '#ff00ff'
            });
        }
    }

    castSpreadAttack() {
        // Fire 12 projectiles in all directions
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            const speed = 3;

            this.projectiles.push({
                x: this.x,
                y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 10,
                lifetime: 180,
                color: '#ff6600'
            });
        }
    }

    summonEnemies() {
        // Summon 3-5 enemies around the boss
        const numSummons = 3 + Math.floor(Math.random() * 3);

        for (let i = 0; i < numSummons; i++) {
            if (this.summonedEnemies.length >= this.maxSummons) break;

            const angle = (Math.PI * 2 / numSummons) * i;
            const distance = 80 + Math.random() * 40;
            const x = this.x + Math.cos(angle) * distance;
            const y = this.y + Math.sin(angle) * distance;

            // Summon normal enemies
            const enemy = new Enemy(x, y);
            gameState.enemies.push(enemy);
            this.summonedEnemies.push(enemy);

            // Spawn effect
            createParticles(x, y, '#00ff00');
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y + this.floatOffset);
        const time = Date.now() * 0.003;

        // Draw custom particles
        this.particles.forEach(p => {
            const pScreen = toScreen(p.x, p.y);
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(pScreen.x, pScreen.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Draw projectiles
        this.projectiles.forEach(proj => {
            const projScreen = toScreen(proj.x, proj.y);

            ctx.shadowBlur = 15;
            ctx.shadowColor = proj.color;
            ctx.fillStyle = proj.color;
            ctx.beginPath();
            ctx.arc(projScreen.x, projScreen.y, proj.size, 0, Math.PI * 2);
            ctx.fill();

            // Inner glow
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(projScreen.x, projScreen.y, proj.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });

        // Draw beam attack
        if (this.beamActive) {
            ctx.save();
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 15;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0000';
            ctx.globalAlpha = 0.7;

            ctx.beginPath();
            ctx.moveTo(screen.x, screen.y);
            ctx.lineTo(
                screen.x + Math.cos(this.beamAngle) * this.beamRange,
                screen.y + Math.sin(this.beamAngle) * this.beamRange
            );
            ctx.stroke();

            // Inner beam
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(screen.x, screen.y);
            ctx.lineTo(
                screen.x + Math.cos(this.beamAngle) * this.beamRange,
                screen.y + Math.sin(this.beamAngle) * this.beamRange
            );
            ctx.stroke();

            ctx.restore();
        }

        // Draw floating aura rings
        for (let i = 0; i < 3; i++) {
            const ringTime = this.auraRotation + i * (Math.PI * 2 / 3);
            const ringRadius = this.size + 15 + Math.sin(time * 2 + i) * 8;

            ctx.strokeStyle = this.state === 'summoning' ? '#00ff00' :
                             this.state === 'casting' ? '#ff6600' :
                             this.state === 'channeling' ? '#ff0000' :
                             '#9400d3';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, ringRadius, ringTime, ringTime + Math.PI);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;

        // Draw main body with dramatic glow
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#9400d3';

        // Outer dark robe
        ctx.fillStyle = '#1a0033';
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y + 5, this.size, this.size + 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // Middle robe
        ctx.fillStyle = '#4b0082';
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y, this.size - 5, this.size - 3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Inner core
        ctx.fillStyle = '#6a0dad';
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y, this.size - 15, this.size - 15, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;

        // Draw skull face
        const skullSize = this.size * 0.5;

        // Eye sockets (glowing)
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0000';
        ctx.beginPath();
        ctx.ellipse(screen.x - skullSize * 0.4, screen.y - skullSize * 0.2, skullSize * 0.25, skullSize * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(screen.x + skullSize * 0.4, screen.y - skullSize * 0.2, skullSize * 0.25, skullSize * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Bright eye glow
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(screen.x - skullSize * 0.4, screen.y - skullSize * 0.2, skullSize * 0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(screen.x + skullSize * 0.4, screen.y - skullSize * 0.2, skullSize * 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Draw shield if active
        if (this.hasShield && this.shieldHp > 0) {
            const shieldAlpha = 0.3 + (this.shieldHp / this.maxShieldHp) * 0.4;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.globalAlpha = shieldAlpha;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';

            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.size + 20, 0, Math.PI * 2);
            ctx.stroke();

            // Shield hexagons
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + time;
                const hx = screen.x + Math.cos(angle) * (this.size + 20);
                const hy = screen.y + Math.sin(angle) * (this.size + 20);

                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(hx, hy, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        // State indicator
        if (this.state === 'summoning') {
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SUMMONING...', screen.x, screen.y - this.size - 30);
        } else if (this.state === 'casting') {
            ctx.fillStyle = '#ff6600';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CASTING...', screen.x, screen.y - this.size - 30);
        }

        // Boss health bars
        const barWidth = 80;
        const barHeight = 8;
        const healthPercent = this.hp / this.maxHp;

        // HP bar background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 50, barWidth, barHeight);

        // HP bar fill
        ctx.fillStyle = '#e94560';
        ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 50, barWidth * healthPercent, barHeight);

        // HP bar border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(screen.x - barWidth / 2, screen.y - this.size - 50, barWidth, barHeight);

        // Shield bar (if shield exists)
        if (this.hasShield && this.shieldHp > 0) {
            const shieldPercent = this.shieldHp / this.maxShieldHp;

            ctx.fillStyle = '#0a0a1e';
            ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 60, barWidth, 6);

            ctx.fillStyle = '#00ffff';
            ctx.fillRect(screen.x - barWidth / 2, screen.y - this.size - 60, barWidth * shieldPercent, 6);

            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(screen.x - barWidth / 2, screen.y - this.size - 60, barWidth, 6);
        }

        // Boss name
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff00ff';
        ctx.fillText('NECROMANCER', screen.x, screen.y - this.size - 65);
        ctx.shadowBlur = 0;
    }

    takeDamage(amount) {
        // Shield absorbs damage first
        if (this.hasShield && this.shieldHp > 0) {
            this.shieldHp -= amount;
            this.shieldRegenCooldown = this.shieldRegenDelay;

            if (this.shieldHp <= 0) {
                this.shieldHp = 0;
                // Shield broken effect
                createParticles(this.x, this.y, '#00ffff');
            }
            return false;
        }

        // Otherwise damage HP
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Arch-Demon Boss Class - Massive end-game boss with multiple phases
class ArchDemonBoss {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 60; // Massive size
        this.speed = CONFIG.enemy.speed * 0.2; // Very slow
        this.hp = 2000; // Boss HP
        this.maxHp = 2000;
        this.damage = 35;
        this.slowedUntil = 0;
        this.isBoss = true;
        this.isMajorBoss = true;

        // Phase system
        this.phase = 1; // 1, 2, 3 (gets more aggressive)
        this.lastPhaseChange = Date.now();

        // Boss behavior - more complex state machine
        this.state = 'idle'; // idle, meteor_rain, fire_wave, summon_minions, enrage, teleport_strike
        this.stateStartTime = Date.now();
        this.stateDurations = {
            idle: 2000,
            meteor_rain: 4000,
            fire_wave: 3000,
            summon_minions: 3000,
            enrage: 5000,
            teleport_strike: 2000
        };

        // Attack properties
        this.projectiles = [];
        this.meteors = [];
        this.fireWaves = [];
        this.lastMeteorTime = 0;
        this.meteorCooldown = 200; // Very fast meteors

        // Summoning
        this.summonedMinions = [];
        this.maxMinions = 15;

        // Enrage mechanics
        this.isEnraged = false;
        this.enrageDamageMultiplier = 1;

        // Teleport strike
        this.isTeleporting = false;
        this.teleportProgress = 0;
        this.teleportStartX = x;
        this.teleportStartY = y;
        this.teleportEndX = x;
        this.teleportEndY = y;
        this.teleportStrikeDamage = 50;

        // Visual effects
        this.wingFlap = 0;
        this.breatheFire = false;
        this.fireBreathAngle = 0;
        this.auraIntensity = 0;
        this.particles = [];
        this.groundCracks = [];

        // Death explosion color palette (red/orange for arch-demon)
        this.colorPalette = ['#dc2626', '#ef4444', '#f97316', '#991b1b', '#fb923c'];

        // Shield system
        this.shields = [
            { hp: 200, maxHp: 200, broken: false, color: '#ff0000', name: 'Fire Shield' },
            { hp: 200, maxHp: 200, broken: false, color: '#00ff00', name: 'Nature Shield' },
            { hp: 200, maxHp: 200, broken: false, color: '#0000ff', name: 'Frost Shield' }
        ];

        // Ground slam attack
        this.chargingSlam = false;
        this.slamChargeTime = 0;
        this.slamRadius = 0;

        // Attacks counter for phase transitions
        this.attacksInPhase = 0;
    }

    update() {
        const currentTime = Date.now();
        const timeSinceStateStart = currentTime - this.stateStartTime;

        // Update visual effects
        this.wingFlap = Math.sin(currentTime * 0.003) * 15;
        this.auraIntensity = 0.5 + Math.sin(currentTime * 0.005) * 0.3;

        // Check phase transitions (based on HP)
        const hpPercent = this.hp / this.maxHp;
        if (hpPercent < 0.66 && this.phase === 1) {
            this.phase = 2;
            this.enrageDamageMultiplier = 1.5;
            console.log('ðŸ”¥ ARCH-DEMON ENTERS PHASE 2!');
            this.createPhaseTransitionEffect();
        } else if (hpPercent < 0.33 && this.phase === 2) {
            this.phase = 3;
            this.enrageDamageMultiplier = 2;
            this.isEnraged = true;
            console.log('ðŸ’€ ARCH-DEMON ENTERS PHASE 3 - ENRAGED!');
            this.createPhaseTransitionEffect();
        }

        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= p.decay || 0.02;
            p.size *= 0.98;
            p.lifetime--;

            if (p.alpha <= 0 || p.size < 0.5 || p.lifetime <= 0) {
                this.particles.splice(i, 1);
            }
        }

        // State machine - different behaviors per phase
        if (this.state === 'idle') {
            // Move towards player menacingly
            const dx = gameState.player.x - this.x;
            const dy = gameState.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 200) {
                this.x += (dx / distance) * this.speed;
                this.y += (dy / distance) * this.speed;
            }

            if (timeSinceStateStart > this.stateDurations.idle) {
                this.chooseNextAttack();
            }
        } else if (this.state === 'meteor_rain') {
            // Rain meteors around player
            if (currentTime - this.lastMeteorTime > this.meteorCooldown) {
                this.summonMeteor();
                this.lastMeteorTime = currentTime;
            }

            if (timeSinceStateStart > this.stateDurations.meteor_rain) {
                this.state = 'idle';
                this.stateStartTime = currentTime;
                this.attacksInPhase++;
            }
        } else if (this.state === 'fire_wave') {
            // Create expanding fire waves
            if (timeSinceStateStart < this.stateDurations.fire_wave) {
                if (Math.floor(timeSinceStateStart / 500) > this.fireWaves.length) {
                    this.createFireWave();
                }
            } else {
                this.state = 'idle';
                this.stateStartTime = currentTime;
                this.attacksInPhase++;
            }
        } else if (this.state === 'summon_minions') {
            if (timeSinceStateStart > this.stateDurations.summon_minions) {
                this.summonMinions();
                this.state = 'idle';
                this.stateStartTime = currentTime;
                this.attacksInPhase++;
            }

            // Summoning particles
            if (Math.random() < 0.2) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 40 + Math.random() * 30;
                this.particles.push({
                    x: this.x + Math.cos(angle) * dist,
                    y: this.y + Math.sin(angle) * dist,
                    vx: Math.cos(angle) * -1,
                    vy: Math.sin(angle) * -1,
                    size: 6,
                    alpha: 1,
                    color: '#ff0000',
                    lifetime: 60
                });
            }
        } else if (this.state === 'teleport_strike') {
            if (!this.isTeleporting) {
                // Start teleport
                this.isTeleporting = true;
                this.teleportProgress = 0;
                this.teleportStartX = this.x;
                this.teleportStartY = this.y;

                // Teleport behind player
                const angleToPlayer = Math.atan2(
                    gameState.player.y - this.y,
                    gameState.player.x - this.x
                );
                const distance = 100;
                this.teleportEndX = gameState.player.x - Math.cos(angleToPlayer) * distance;
                this.teleportEndY = gameState.player.y - Math.sin(angleToPlayer) * distance;

                // Clamp to world
                this.teleportEndX = Math.max(this.size, Math.min(CONFIG.world.width - this.size, this.teleportEndX));
                this.teleportEndY = Math.max(this.size, Math.min(CONFIG.world.height - this.size, this.teleportEndY));
            } else {
                this.teleportProgress += 0.05;

                if (this.teleportProgress >= 1) {
                    this.x = this.teleportEndX;
                    this.y = this.teleportEndY;

                    // Teleport strike damage in area
                    const strikeRadius = 80;
                    const playerDist = Math.sqrt(
                        Math.pow(gameState.player.x - this.x, 2) +
                        Math.pow(gameState.player.y - this.y, 2)
                    );

                    if (playerDist < strikeRadius) {
                        player.takeDamage(this.teleportStrikeDamage);
                        createParticles(gameState.player.x, gameState.player.y, '#ff0000');
                    }

                    // Create shockwave
                    this.createShockwave();

                    this.isTeleporting = false;
                    this.state = 'idle';
                    this.stateStartTime = currentTime;
                    this.attacksInPhase++;
                }
            }
        } else if (this.state === 'enrage') {
            // Violent thrashing and fast attacks
            this.breatheFire = true;
            this.fireBreathAngle += 0.03;

            // Fire breath projectiles
            if (Math.random() < 0.15) {
                const spread = 0.3;
                for (let i = -1; i <= 1; i++) {
                    const angle = Math.atan2(
                        gameState.player.y - this.y,
                        gameState.player.x - this.x
                    ) + i * spread;

                    this.projectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        size: 12,
                        lifetime: 150,
                        color: '#ff4400',
                        damage: this.damage * this.enrageDamageMultiplier
                    });
                }
            }

            if (timeSinceStateStart > this.stateDurations.enrage) {
                this.breatheFire = false;
                this.state = 'idle';
                this.stateStartTime = currentTime;
                this.attacksInPhase++;
            }
        }

        // Update meteors
        for (let i = this.meteors.length - 1; i >= 0; i--) {
            const meteor = this.meteors[i];
            meteor.y += meteor.speed;
            meteor.speed += 0.2; // Accelerate

            // Check if hit ground
            if (meteor.y >= meteor.targetY) {
                // Explosion damage radius
                const explosionRadius = meteor.radius || 80;

                // Damage enemies in explosion radius
                let hitAnyEnemy = false;
                gameState.enemies.forEach(enemy => {
                    const enemyDist = Math.sqrt(
                        Math.pow(enemy.x - meteor.x, 2) +
                        Math.pow(enemy.y - meteor.y, 2)
                    );

                    if (enemyDist < explosionRadius) {
                        const damage = (meteor.damage || 150) * (1 - enemyDist / explosionRadius);
                        enemy.hp -= damage;
                        hitAnyEnemy = true;
                    }
                });

                // Play explosion sound if hit enemies
                if (hitAnyEnemy) {
                    SoundSystem.playHit('explosion');
                }

                // Also damage player if it's a boss meteor
                const playerDist = Math.sqrt(
                    Math.pow(gameState.player.x - meteor.x, 2) +
                    Math.pow(gameState.player.y - meteor.y, 2)
                );

                if (playerDist < explosionRadius && !gameState.meteorStormStartTime) {
                    // Only damage player if it's NOT from ultimate
                    const damage = 25 * (1 - playerDist / explosionRadius);
                    player.takeDamage(damage);
                }

                // Create explosion particles
                for (let j = 0; j < 20; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    this.particles.push({
                        x: meteor.x,
                        y: meteor.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: 8 + Math.random() * 8,
                        alpha: 1,
                        color: gameState.meteorStormStartTime ? '#8b5cf6' : '#ff6600',
                        lifetime: 40
                    });
                }

                this.meteors.splice(i, 1);
            }
        }

        // Update fire waves
        for (let i = this.fireWaves.length - 1; i >= 0; i--) {
            const wave = this.fireWaves[i];
            wave.radius += wave.speed;
            wave.alpha -= 0.01;

            // Check collision with player
            const playerDist = Math.sqrt(
                Math.pow(gameState.player.x - wave.x, 2) +
                Math.pow(gameState.player.y - wave.y, 2)
            );

            if (Math.abs(playerDist - wave.radius) < 20 && !wave.hitPlayer) {
                player.takeDamage(30);
                wave.hitPlayer = true;
            }

            if (wave.alpha <= 0 || wave.radius > 400) {
                this.fireWaves.splice(i, 1);
            }
        }

        // Update projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.x += proj.vx;
            proj.y += proj.vy;
            proj.lifetime--;

            const playerDist = Math.sqrt(
                Math.pow(proj.x - gameState.player.x, 2) +
                Math.pow(proj.y - gameState.player.y, 2)
            );

            if (playerDist < CONFIG.player.size + proj.size) {
                player.takeDamage(proj.damage || this.damage);
                this.projectiles.splice(i, 1);
                createParticles(proj.x, proj.y, proj.color);
            } else if (proj.lifetime <= 0) {
                this.projectiles.splice(i, 1);
            }
        }

        // Contact damage
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.02);
        }

        // Clean up dead minions
        this.summonedMinions = this.summonedMinions.filter(m =>
            gameState.enemies.includes(m)
        );
    }

    chooseNextAttack() {
        const attacks = ['meteor_rain', 'fire_wave', 'summon_minions'];

        // Phase 2+ adds more attacks
        if (this.phase >= 2) {
            attacks.push('teleport_strike');
        }

        // Phase 3 adds enrage
        if (this.phase >= 3 && Math.random() < 0.3) {
            attacks.push('enrage');
        }

        // Don't summon if already have max minions
        if (this.summonedMinions.length >= this.maxMinions) {
            const idx = attacks.indexOf('summon_minions');
            if (idx > -1) attacks.splice(idx, 1);
        }

        const chosen = attacks[Math.floor(Math.random() * attacks.length)];
        this.state = chosen;
        this.stateStartTime = Date.now();

        console.log(`ðŸ‘¹ Arch-Demon uses ${chosen}!`);
    }

    summonMeteor() {
        // Random position around player
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 150;
        const targetX = gameState.player.x + Math.cos(angle) * distance;
        const targetY = gameState.player.y + Math.sin(angle) * distance;

        this.meteors.push({
            x: targetX,
            y: targetY - 400, // Start above
            targetY: targetY,
            speed: 3,
            size: 15,
            warningTime: 60
        });
    }

    createFireWave() {
        this.fireWaves.push({
            x: this.x,
            y: this.y,
            radius: 0,
            speed: 4,
            alpha: 1,
            hitPlayer: false
        });
    }

    summonMinions() {
        const numMinions = 4 + Math.floor(Math.random() * 4);

        for (let i = 0; i < numMinions; i++) {
            if (this.summonedMinions.length >= this.maxMinions) break;

            const angle = (Math.PI * 2 / numMinions) * i;
            const distance = 100 + Math.random() * 50;
            const x = this.x + Math.cos(angle) * distance;
            const y = this.y + Math.sin(angle) * distance;

            // Summon charger enemies (more dangerous)
            const minion = new ChargerEnemy(x, y);
            gameState.enemies.push(minion);
            this.summonedMinions.push(minion);

            createParticles(x, y, '#ff0000');
        }
    }

    createShockwave() {
        for (let i = 0; i < 40; i++) {
            const angle = (Math.PI * 2 / 40) * i;
            const speed = 3 + Math.random() * 2;
            this.particles.push({
                x: this.x,
                y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 10,
                alpha: 1,
                color: '#ff0000',
                lifetime: 50
            });
        }
    }

    createPhaseTransitionEffect() {
        // Massive explosion
        for (let i = 0; i < 100; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 5;
            this.particles.push({
                x: this.x,
                y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 15 + Math.random() * 10,
                alpha: 1,
                color: this.phase === 2 ? '#ff6600' : '#ff0000',
                lifetime: 80,
                decay: 0.015
            });
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const time = Date.now() * 0.003;

        // Draw particles
        this.particles.forEach(p => {
            const pScreen = toScreen(p.x, p.y);
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(pScreen.x, pScreen.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;

        // Draw meteors with warning indicators
        this.meteors.forEach(meteor => {
            // Warning indicator on ground
            const targetScreen = toScreen(meteor.x, meteor.targetY);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(targetScreen.x, targetScreen.y, 60, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(targetScreen.x, targetScreen.y, 60, 0, Math.PI * 2);
            ctx.stroke();

            // Meteor itself
            const meteorScreen = toScreen(meteor.x, meteor.y);
            ctx.fillStyle = '#ff3300';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff6600';
            ctx.beginPath();
            ctx.arc(meteorScreen.x, meteorScreen.y, meteor.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });

        // Draw fire waves
        this.fireWaves.forEach(wave => {
            const waveScreen = toScreen(wave.x, wave.y);
            ctx.strokeStyle = `rgba(255, 100, 0, ${wave.alpha})`;
            ctx.lineWidth = 15;
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#ff6600';
            ctx.beginPath();
            ctx.arc(waveScreen.x, waveScreen.y, wave.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        });

        // Draw projectiles
        this.projectiles.forEach(proj => {
            const projScreen = toScreen(proj.x, proj.y);
            ctx.shadowBlur = 20;
            ctx.shadowColor = proj.color;
            ctx.fillStyle = proj.color;
            ctx.beginPath();
            ctx.arc(projScreen.x, projScreen.y, proj.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });

        // Teleport effect
        if (this.isTeleporting) {
            const startScreen = toScreen(this.teleportStartX, this.teleportStartY);
            const endScreen = toScreen(this.teleportEndX, this.teleportEndY);

            ctx.globalAlpha = 1 - this.teleportProgress;
            this.drawDemonBody(startScreen.x, startScreen.y);
            ctx.globalAlpha = this.teleportProgress;
            this.drawDemonBody(endScreen.x, endScreen.y);
            ctx.globalAlpha = 1;
        } else {
            this.drawDemonBody(screen.x, screen.y);
        }
    }

    drawDemonBody(screenX, screenY) {
        const time = Date.now() * 0.003;

        // Phase color scheme
        let primaryColor, secondaryColor, eyeColor;
        if (this.phase === 1) {
            primaryColor = '#8b0000';
            secondaryColor = '#4a0000';
            eyeColor = '#ff6600';
        } else if (this.phase === 2) {
            primaryColor = '#b30000';
            secondaryColor = '#660000';
            eyeColor = '#ff3300';
        } else {
            primaryColor = '#ff0000';
            secondaryColor = '#990000';
            eyeColor = '#ffff00';
        }

        // Massive glowing aura
        ctx.shadowBlur = 50 * this.auraIntensity;
        ctx.shadowColor = primaryColor;

        // Draw wings
        const wingSpread = this.size * 1.5 + this.wingFlap;

        // Left wing
        ctx.fillStyle = secondaryColor;
        ctx.beginPath();
        ctx.ellipse(screenX - wingSpread, screenY, this.size * 0.6, this.size * 1.2, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // Right wing
        ctx.beginPath();
        ctx.ellipse(screenX + wingSpread, screenY, this.size * 0.6, this.size * 1.2, 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Main body
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        ctx.ellipse(screenX, screenY, this.size, this.size * 1.3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Inner body
        ctx.fillStyle = secondaryColor;
        ctx.beginPath();
        ctx.ellipse(screenX, screenY, this.size - 10, this.size * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;

        // Horns
        const hornSize = this.size * 0.5;
        ctx.fillStyle = '#1a0000';
        ctx.beginPath();
        ctx.moveTo(screenX - this.size * 0.6, screenY - this.size * 0.8);
        ctx.lineTo(screenX - this.size * 0.8, screenY - this.size * 1.5);
        ctx.lineTo(screenX - this.size * 0.4, screenY - this.size * 0.7);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(screenX + this.size * 0.6, screenY - this.size * 0.8);
        ctx.lineTo(screenX + this.size * 0.8, screenY - this.size * 1.5);
        ctx.lineTo(screenX + this.size * 0.4, screenY - this.size * 0.7);
        ctx.fill();

        // Eyes (massive glowing)
        ctx.shadowBlur = 30;
        ctx.shadowColor = eyeColor;
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.ellipse(screenX - this.size * 0.3, screenY - this.size * 0.3, this.size * 0.2, this.size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(screenX + this.size * 0.3, screenY - this.size * 0.3, this.size * 0.2, this.size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Mouth (flaming if enraged)
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(screenX, screenY + this.size * 0.3, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI);
        ctx.fill();

        if (this.breatheFire) {
            ctx.fillStyle = '#ff4400';
            for (let i = 0; i < 3; i++) {
                ctx.globalAlpha = 0.7 - i * 0.2;
                ctx.beginPath();
                ctx.arc(
                    screenX + Math.cos(this.fireBreathAngle) * (40 + i * 20),
                    screenY + Math.sin(this.fireBreathAngle) * (40 + i * 20),
                    10 + i * 5,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // Draw shields
        this.shields.forEach((shield, index) => {
            if (!shield.broken && shield.hp > 0) {
                const shieldRadius = this.size + 30 + (index * 15);
                const shieldAlpha = 0.2 + (shield.hp / shield.maxHp) * 0.4;

                ctx.strokeStyle = shield.color;
                ctx.lineWidth = 6;
                ctx.globalAlpha = shieldAlpha;
                ctx.shadowBlur = 25;
                ctx.shadowColor = shield.color;

                ctx.beginPath();
                ctx.arc(screenX, screenY, shieldRadius, time + index, time + index + Math.PI);
                ctx.stroke();

                // Shield runes
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i + time * 0.5;
                    const rx = screenX + Math.cos(angle) * shieldRadius;
                    const ry = screenY + Math.sin(angle) * shieldRadius;

                    ctx.fillStyle = shield.color;
                    ctx.beginPath();
                    ctx.arc(rx, ry, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        });

        // Boss health bars
        const barWidth = 120;
        const barHeight = 10;
        const healthPercent = this.hp / this.maxHp;

        // HP bar
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(screenX - barWidth / 2, screenY - this.size - 100, barWidth, barHeight);

        ctx.fillStyle = '#ff0000';
        ctx.fillRect(screenX - barWidth / 2, screenY - this.size - 100, barWidth * healthPercent, barHeight);

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(screenX - barWidth / 2, screenY - this.size - 100, barWidth, barHeight);

        // Shield bars
        let shieldYOffset = -110;
        this.shields.forEach(shield => {
            if (!shield.broken && shield.hp > 0) {
                const shieldPercent = shield.hp / shield.maxHp;

                ctx.fillStyle = '#0a0a1e';
                ctx.fillRect(screenX - barWidth / 2, screenY - this.size + shieldYOffset, barWidth, 6);

                ctx.fillStyle = shield.color;
                ctx.fillRect(screenX - barWidth / 2, screenY - this.size + shieldYOffset, barWidth * shieldPercent, 6);

                ctx.strokeStyle = shield.color;
                ctx.lineWidth = 1;
                ctx.strokeRect(screenX - barWidth / 2, screenY - this.size + shieldYOffset, barWidth, 6);

                shieldYOffset -= 8;
            }
        });

        // Boss name and phase
        ctx.fillStyle = '#ff0000';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0000';
        ctx.fillText(`ARCH-DEMON`, screenX, screenY - this.size - 120);

        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = this.phase === 3 ? '#ffff00' : '#ff6600';
        ctx.fillText(`PHASE ${this.phase}${this.isEnraged ? ' - ENRAGED' : ''}`, screenX, screenY - this.size - 135);
        ctx.shadowBlur = 0;
    }

    takeDamage(amount) {
        // Shields absorb damage first (in order)
        for (let shield of this.shields) {
            if (!shield.broken && shield.hp > 0) {
                shield.hp -= amount;

                if (shield.hp <= 0) {
                    shield.hp = 0;
                    shield.broken = true;
                    console.log(`ðŸ’¥ ${shield.name} BROKEN!`);
                    this.createShockwave();
                }
                return false;
            }
        }

        // All shields down, damage HP
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Splitter Enemy - Splits into smaller enemies when killed
class SplitterEnemy {
    constructor(x, y, generation = 1) {
        this.x = x;
        this.y = y;
        this.generation = generation; // 1 = big, 2 = medium, 3 = small
        this.size = CONFIG.enemy.size + (4 - generation) * 8;

        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * (1 + generation * 0.3) * difficulty.speed;
        this.baseHp = 15 * (4 - generation); // Reduced from 20
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 6; // Reduced from 8
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Visual properties
        this.colorPalette = ['#ff6b6b', '#ff8787', '#ffa5a5', '#ff4d4d', '#ff9999'];
        this.pulsePhase = Math.random() * Math.PI * 2;
    }

    update() {
        // Move towards player
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

        if (distance > 0) {
            this.x += (dx / distance) * currentSpeed;
            this.y += (dy / distance) * currentSpeed;
        }

        this.pulsePhase += 0.1;

        // Check collision with player
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.016);
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const pulse = Math.sin(this.pulsePhase) * 3;

        // Pulsating blob
        ctx.fillStyle = this.colorPalette[0];
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.colorPalette[1];
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size + pulse, 0, Math.PI * 2);
        ctx.fill();

        // Inner core
        ctx.fillStyle = this.colorPalette[3];
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#000000';
        ctx.fillRect(screen.x - this.size * 0.3, screen.y - this.size * 0.2, this.size * 0.2, this.size * 0.2);
        ctx.fillRect(screen.x + this.size * 0.1, screen.y - this.size * 0.2, this.size * 0.2, this.size * 0.2);

        ctx.shadowBlur = 0;

        // Health bar
        const barWidth = this.size * 2;
        const barHeight = 4;
        const barX = screen.x - barWidth / 2;
        const barY = screen.y - this.size - 10;

        ctx.fillStyle = '#ff0000';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }

    // Called when enemy dies - splits into smaller versions
    onDeath() {
        if (this.generation < 3) {
            // Split into 2 smaller enemies
            const angleOffset = Math.PI / 3;
            for (let i = 0; i < 2; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = 30;
                gameState.enemies.push(new SplitterEnemy(
                    this.x + Math.cos(angle) * spawnDist,
                    this.y + Math.sin(angle) * spawnDist,
                    this.generation + 1
                ));
            }
        }
    }
}

// Ranged Enemy - Shoots projectiles at player
class RangedEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size;

        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * 0.7 * difficulty.speed; // Slower
        this.baseHp = 20; // Reduced from 25
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 8; // Reduced from 12
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Ranged behavior
        this.attackRange = 250;
        this.keepDistance = 180;
        this.shootCooldown = 2500; // Increased from 2000 (slower shooting)
        this.lastShot = Date.now();

        this.colorPalette = ['#9b59b6', '#8e44ad', '#af7ac5', '#7d3c98', '#bb8fce'];
        this.projectiles = [];
    }

    update() {
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

        // Keep distance from player
        if (distance < this.keepDistance) {
            // Move away
            if (distance > 0) {
                this.x -= (dx / distance) * currentSpeed;
                this.y -= (dy / distance) * currentSpeed;
            }
        } else if (distance > this.attackRange) {
            // Move closer
            if (distance > 0) {
                this.x += (dx / distance) * currentSpeed;
                this.y += (dy / distance) * currentSpeed;
            }
        }

        // Shoot at player
        const currentTime = Date.now();
        if (currentTime - this.lastShot > this.shootCooldown && distance < this.attackRange) {
            this.shoot();
            this.lastShot = currentTime;
        }
    }

    shoot() {
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 0) {
            gameState.enemyProjectiles = gameState.enemyProjectiles || [];
            gameState.enemyProjectiles.push({
                x: this.x,
                y: this.y,
                vx: (dx / distance) * 4,
                vy: (dy / distance) * 4,
                damage: this.damage,
                size: 6,
                color: '#9b59b6'
            });
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Archer body
        ctx.fillStyle = this.colorPalette[0];
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.colorPalette[1];
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Bow
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(screen.x + this.size, screen.y, this.size * 0.8, -Math.PI / 4, Math.PI / 4);
        ctx.stroke();

        // Eyes
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(screen.x - 5, screen.y - 3, 3, 0, Math.PI * 2);
        ctx.arc(screen.x + 5, screen.y - 3, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;

        // Health bar
        const barWidth = this.size * 2;
        const barHeight = 4;
        const barX = screen.x - barWidth / 2;
        const barY = screen.y - this.size - 10;

        ctx.fillStyle = '#330000';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = '#9b59b6';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Tank Enemy - Very slow, very tanky, pushes player back
class TankEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size * 1.8;

        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * 0.4 * difficulty.speed; // Very slow
        this.baseHp = 120; // Reduced from 200
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 15; // Reduced from 20
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Tank properties
        this.armor = 0.6; // Reduced from 0.5 (takes 40% damage instead of 50%)
        this.pushStrength = 2; // Reduced from 3

        this.colorPalette = ['#34495e', '#2c3e50', '#455a64', '#1c2833', '#566573'];
    }

    update() {
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

        if (distance > 0) {
            this.x += (dx / distance) * currentSpeed;
            this.y += (dy / distance) * currentSpeed;
        }

        // Check collision with player - push back
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.016);

            // Push player back
            if (playerDist > 0) {
                const pushX = -(dx / playerDist) * this.pushStrength;
                const pushY = -(dy / playerDist) * this.pushStrength;
                gameState.player.x += pushX;
                gameState.player.y += pushY;

                // Keep player in bounds
                gameState.player.x = Math.max(CONFIG.player.size, Math.min(CONFIG.world.width - CONFIG.player.size, gameState.player.x));
                gameState.player.y = Math.max(CONFIG.player.size, Math.min(CONFIG.world.height - CONFIG.player.size, gameState.player.y));
            }
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Tank body - large and armored
        ctx.fillStyle = this.colorPalette[0];
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#000000';

        // Main body (rectangle)
        ctx.fillRect(screen.x - this.size, screen.y - this.size * 0.8, this.size * 2, this.size * 1.6);

        // Armor plating lines
        ctx.strokeStyle = this.colorPalette[1];
        ctx.lineWidth = 3;
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(screen.x - this.size, screen.y + i * this.size * 0.4);
            ctx.lineTo(screen.x + this.size, screen.y + i * this.size * 0.4);
            ctx.stroke();
        }

        // Eyes (glowing red)
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(screen.x - this.size * 0.4, screen.y - this.size * 0.3, 5, 0, Math.PI * 2);
        ctx.arc(screen.x + this.size * 0.4, screen.y - this.size * 0.3, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;

        // Health bar
        const barWidth = this.size * 2.5;
        const barHeight = 6;
        const barX = screen.x - barWidth / 2;
        const barY = screen.y - this.size * 1.2;

        ctx.fillStyle = '#000000';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);

        // Armor indicator
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('ðŸ›¡ï¸', screen.x - 8, screen.y + this.size + 10);
    }

    takeDamage(amount) {
        // Apply armor reduction
        this.hp -= amount * this.armor;
        return this.hp <= 0;
    }
}

// Healer Enemy - Heals nearby enemies
class HealerEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size * 0.9;

        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * 0.6 * difficulty.speed;
        this.baseHp = 30;
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 5;
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Healer properties
        this.healRange = 150;
        this.healAmount = 2;
        this.healCooldown = 1000;
        this.lastHeal = Date.now();

        this.colorPalette = ['#2ecc71', '#27ae60', '#52d273', '#229954', '#7dcea0'];
        this.healPulse = 0;
    }

    update() {
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

        // Stay at medium distance
        const preferredDistance = 200;
        if (distance < preferredDistance - 50) {
            // Move away
            if (distance > 0) {
                this.x -= (dx / distance) * currentSpeed;
                this.y -= (dy / distance) * currentSpeed;
            }
        } else if (distance > preferredDistance + 50) {
            // Move closer
            if (distance > 0) {
                this.x += (dx / distance) * currentSpeed;
                this.y += (dy / distance) * currentSpeed;
            }
        }

        // Heal nearby enemies
        const currentTime = Date.now();
        if (currentTime - this.lastHeal > this.healCooldown) {
            this.healNearbyEnemies();
            this.lastHeal = currentTime;
        }

        this.healPulse += 0.2;

        // Check collision with player
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.016);
        }
    }

    healNearbyEnemies() {
        let healed = false;
        gameState.enemies.forEach(enemy => {
            if (enemy === this) return;

            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.healRange && enemy.hp < enemy.maxHp) {
                enemy.hp = Math.min(enemy.maxHp, enemy.hp + this.healAmount);
                healed = true;

                // Heal particles
                for (let i = 0; i < 3; i++) {
                    gameState.particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -2 - Math.random(),
                        size: 4,
                        color: '#2ecc71',
                        alpha: 1,
                        decay: 0.02,
                        lifetime: 30
                    });
                }
            }
        });

        if (healed) {
            this.healPulse = 0; // Reset pulse for visual feedback
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const pulse = Math.abs(Math.sin(this.healPulse)) * 10;

        // Healing aura
        ctx.strokeStyle = `rgba(46, 204, 113, ${0.3 + Math.sin(this.healPulse) * 0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.healRange * 0.5 + pulse, 0, Math.PI * 2);
        ctx.stroke();

        // Healer body
        ctx.fillStyle = this.colorPalette[0];
        ctx.shadowBlur = 12;
        ctx.shadowColor = this.colorPalette[1];
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Cross symbol
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(screen.x - 3, screen.y - 10, 6, 20);
        ctx.fillRect(screen.x - 10, screen.y - 3, 20, 6);

        // Halo
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y - this.size - 8, this.size * 0.6, 0, Math.PI * 2);
        ctx.stroke();

        ctx.shadowBlur = 0;

        // Health bar
        const barWidth = this.size * 2;
        const barHeight = 4;
        const barX = screen.x - barWidth / 2;
        const barY = screen.y - this.size - 20;

        ctx.fillStyle = '#003300';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Swarm Enemy - Very fast, weak, spawns in groups
class SwarmEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.enemy.size * 0.6;

        const difficulty = getDifficultyMultipliers();
        this.speed = CONFIG.enemy.speed * 2.2 * difficulty.speed; // Very fast
        this.baseHp = 8;
        this.hp = this.baseHp * difficulty.hp;
        this.maxHp = this.hp;
        this.baseDamage = 6;
        this.damage = this.baseDamage * difficulty.damage;
        this.slowedUntil = 0;
        this.difficultyTier = difficulty.intervals;

        // Swarm behavior
        this.swarmRadius = 50;
        this.zigzagPhase = Math.random() * Math.PI * 2;
        this.zigzagSpeed = 0.15;

        this.colorPalette = ['#e67e22', '#d35400', '#f39c12', '#ca6f1e', '#f8b740'];
    }

    update() {
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const currentSpeed = Date.now() < this.slowedUntil ? this.speed * 0.3 : this.speed;

        if (distance > 0) {
            // Zigzag movement
            this.zigzagPhase += this.zigzagSpeed;
            const zigzagOffset = Math.sin(this.zigzagPhase) * 20;

            // Perpendicular direction for zigzag
            const perpX = -dy / distance;
            const perpY = dx / distance;

            this.x += (dx / distance) * currentSpeed + perpX * zigzagOffset * 0.1;
            this.y += (dy / distance) * currentSpeed + perpY * zigzagOffset * 0.1;
        }

        // Check collision with player
        const playerDist = Math.sqrt(
            Math.pow(this.x - gameState.player.x, 2) +
            Math.pow(this.y - gameState.player.y, 2)
        );

        if (playerDist < CONFIG.player.size + this.size) {
            player.takeDamage(this.damage * 0.016);
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Small fast creature
        ctx.fillStyle = this.colorPalette[0];
        ctx.shadowBlur = 6;
        ctx.shadowColor = this.colorPalette[1];

        // Body (elongated)
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y, this.size * 1.2, this.size * 0.8, this.zigzagPhase, 0, Math.PI * 2);
        ctx.fill();

        // Eyes (big relative to body)
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(screen.x - 4, screen.y - 2, 2, 0, Math.PI * 2);
        ctx.arc(screen.x + 4, screen.y - 2, 2, 0, Math.PI * 2);
        ctx.fill();

        // Motion trail
        ctx.strokeStyle = `rgba(230, 126, 34, 0.3)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screen.x, screen.y);
        ctx.lineTo(screen.x - Math.cos(this.zigzagPhase) * 15, screen.y - Math.sin(this.zigzagPhase) * 15);
        ctx.stroke();

        ctx.shadowBlur = 0;

        // No health bar (too small and numerous)
    }

    takeDamage(amount) {
        this.hp -= amount;
        return this.hp <= 0;
    }
}

// Homing Missile Class
class HomingMissile {
    constructor(x, y, weapon) {
        this.x = x;
        this.y = y;
        this.size = 6;
        this.speed = 4;
        this.turnSpeed = 0.1; // How fast missile can turn
        this.damage = weapon.damage;
        this.maxLifetime = 5000; // 5 seconds max
        this.spawnTime = Date.now();
        this.weapon = weapon;
        this.target = null;

        // Start with random direction
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
    }

    update() {
        // Check if missile has expired
        if (Date.now() - this.spawnTime > this.maxLifetime) {
            return true; // Remove missile
        }

        // Find closest enemy if no target or target is dead
        if (!this.target || !gameState.enemies.includes(this.target)) {
            let closestDist = Infinity;
            this.target = null;

            gameState.enemies.forEach(enemy => {
                const dist = Math.sqrt(
                    Math.pow(enemy.x - this.x, 2) +
                    Math.pow(enemy.y - this.y, 2)
                );
                if (dist < closestDist) {
                    closestDist = dist;
                    this.target = enemy;
                }
            });
        }

        // Home towards target
        if (this.target) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                // Desired direction
                const desiredVx = (dx / distance) * this.speed;
                const desiredVy = (dy / distance) * this.speed;

                // Gradually turn towards target
                this.vx += (desiredVx - this.vx) * this.turnSpeed;
                this.vy += (desiredVy - this.vy) * this.turnSpeed;

                // Maintain constant speed
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.vx = (this.vx / currentSpeed) * this.speed;
                this.vy = (this.vy / currentSpeed) * this.speed;
            }
        }

        // Move
        this.x += this.vx;
        this.y += this.vy;

        // Check collision with enemies
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];
            const dist = Math.sqrt(
                Math.pow(this.x - enemy.x, 2) +
                Math.pow(this.y - enemy.y, 2)
            );

            if (dist < enemy.size + this.size) {
                // Hit!
                createParticles(enemy.x, enemy.y, '#ff1493');
                const isDead = enemy.takeDamage(this.damage);

                // Play explosion sound for missiles
                SoundSystem.playHit(isDead ? 'critical' : 'explosion');

                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(i, 1);
                }
                return true; // Remove missile
            }
        }

        return false; // Keep missile
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Pink/red missile with trail
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff1493';

        // Draw missile body
        ctx.fillStyle = '#ff1493';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Glow ring
        ctx.strokeStyle = '#ff69b4';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Direction indicator (small triangle)
        const angle = Math.atan2(this.vy, this.vx);
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(
            screen.x + Math.cos(angle) * this.size,
            screen.y + Math.sin(angle) * this.size
        );
        ctx.lineTo(
            screen.x + Math.cos(angle + 2.5) * (this.size * 0.5),
            screen.y + Math.sin(angle + 2.5) * (this.size * 0.5)
        );
        ctx.lineTo(
            screen.x + Math.cos(angle - 2.5) * (this.size * 0.5),
            screen.y + Math.sin(angle - 2.5) * (this.size * 0.5)
        );
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;
    }
}

// Tornado Class - Spinning vortex that sucks in enemies
class Tornado {
    constructor(x, y, targetX, targetY, weapon) {
        this.x = x;
        this.y = y;
        this.size = 40;
        this.damage = weapon.damage;
        this.weapon = weapon;
        this.rotation = 0;
        this.maxLifetime = 5000; // 5 seconds
        this.spawnTime = Date.now();
        this.pullRadius = 100; // Pull enemies within this radius

        // Move towards target direction
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.vx = (dx / distance) * 2; // Slow moving
        this.vy = (dy / distance) * 2;
    }

    update() {
        // Move
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += 0.2;

        // Check lifetime
        if (Date.now() - this.spawnTime > this.maxLifetime) {
            return true; // Remove
        }

        // Pull in and damage enemies
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];
            const dx = this.x - enemy.x;
            const dy = this.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.pullRadius) {
                // Pull enemy towards tornado
                const pullStrength = 0.3;
                enemy.x += (dx / dist) * pullStrength;
                enemy.y += (dy / dist) * pullStrength;

                // Damage if close
                if (dist < this.size) {
                    createParticles(enemy.x, enemy.y, '#88ff88');
                    const isDead = enemy.takeDamage(this.damage * 0.1); // Damage over time

                    // Play magic sound for tornado (quieter for DoT)
                    if (Math.random() < 0.2) { // Only 20% of the time to avoid spam
                        SoundSystem.playHit(isDead ? 'critical' : 'magic');
                    }

                    if (isDead) {
                        handleEnemyDeath(enemy);
                        gameState.enemies.splice(i, 1);
                    }
                }
            }
        }

        return false; // Keep tornado
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.save();

        // Draw multiple spiral layers to create tornado effect
        for (let layer = 0; layer < 8; layer++) {
            const layerRadius = (layer + 1) * 5;
            const layerAlpha = 1 - (layer / 8) * 0.7;

            // Draw spiral
            ctx.beginPath();
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 4 + this.rotation + (layer * 0.3);
                const radius = layerRadius + (i / 20) * (this.size - layerRadius);
                const x = screen.x + Math.cos(angle) * radius;
                const y = screen.y + Math.sin(angle) * radius;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.strokeStyle = `rgba(100, 255, 150, ${layerAlpha * 0.8})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // Draw swirling particles around tornado
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2 + this.rotation * 2;
            const radius = this.size * 0.7 + Math.sin(this.rotation * 3 + i) * 10;
            const x = screen.x + Math.cos(angle) * radius;
            const y = screen.y + Math.sin(angle) * radius;

            ctx.fillStyle = `rgba(150, 255, 180, ${0.6 + Math.sin(this.rotation * 2 + i) * 0.4})`;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Bright center core
        const coreGradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, 15);
        coreGradient.addColorStop(0, 'rgba(200, 255, 200, 0.9)');
        coreGradient.addColorStop(0.5, 'rgba(100, 255, 150, 0.5)');
        coreGradient.addColorStop(1, 'rgba(100, 255, 150, 0)');
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, 15, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

// Spinning Blade Class - Boomerang that flies out and returns
class SpinningBlade {
    constructor(x, y, targetX, targetY, weapon) {
        this.x = x;
        this.y = y;
        this.startX = x;
        this.startY = y;
        this.size = 8;
        this.damage = weapon.damage;
        this.weapon = weapon;
        this.rotation = 0;
        this.maxDistance = 250;
        this.distanceTraveled = 0;
        this.returning = false;
        this.speed = 6;
        this.hitEnemies = new Set(); // Track which enemies we've hit

        // Initial direction towards target
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.vx = (dx / distance) * this.speed;
        this.vy = (dy / distance) * this.speed;
    }

    update() {
        // Rotate blade
        this.rotation += 0.3;

        if (!this.returning) {
            // Move outward
            this.x += this.vx;
            this.y += this.vy;
            this.distanceTraveled += this.speed;

            // Start returning when max distance reached
            if (this.distanceTraveled >= this.maxDistance) {
                this.returning = true;
                this.hitEnemies.clear(); // Can hit enemies again on return
            }
        } else {
            // Return to player
            const dx = gameState.player.x - this.x;
            const dy = gameState.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 20) {
                return true; // Remove blade when it returns to player
            }

            this.vx = (dx / distance) * this.speed;
            this.vy = (dy / distance) * this.speed;
            this.x += this.vx;
            this.y += this.vy;
        }

        // Check collision with enemies
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];

            // Skip if already hit this enemy in current direction
            if (this.hitEnemies.has(i)) continue;

            const dist = Math.sqrt(
                Math.pow(this.x - enemy.x, 2) +
                Math.pow(this.y - enemy.y, 2)
            );

            if (dist < enemy.size + this.size) {
                // Hit!
                this.hitEnemies.add(i);
                createParticles(enemy.x, enemy.y, '#ff6b6b');
                const isDead = enemy.takeDamage(this.damage);

                // Play blade hit sound
                SoundSystem.playHit(isDead ? 'critical' : 'normal');

                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(i, 1);
                }
            }
        }

        return false; // Keep blade
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.save();
        ctx.translate(screen.x, screen.y);
        ctx.rotate(this.rotation);

        // Draw spinning blade (cross/star shape)
        ctx.strokeStyle = '#ff6b6b';
        ctx.fillStyle = '#ff3333';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0000';

        // Draw 4 blade edges
        for (let i = 0; i < 4; i++) {
            const angle = (Math.PI / 2) * i;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(angle) * this.size * 2,
                Math.sin(angle) * this.size * 2
            );
            ctx.stroke();

            // Blade tip
            ctx.beginPath();
            ctx.arc(
                Math.cos(angle) * this.size * 2,
                Math.sin(angle) * this.size * 2,
                3, 0, Math.PI * 2
            );
            ctx.fill();
        }

        // Center circle
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.restore();

        // Draw motion trail when returning
        if (this.returning) {
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(screen.x, screen.y);
            ctx.lineTo(screen.x - this.vx * 3, screen.y - this.vy * 3);
            ctx.stroke();
        }
    }
}

// Meteor Strike Class - Falls from sky and explodes
class Meteor {
    constructor(targetX, targetY, weapon) {
        // Start high above target
        this.x = targetX + (Math.random() - 0.5) * 100; // Slight randomness
        this.y = targetY - 400; // Start above screen
        this.targetX = targetX;
        this.targetY = targetY;
        this.size = 15;
        this.damage = weapon.damage;
        this.weapon = weapon;
        this.speed = 8;
        this.rotation = 0;
        this.trailParticles = [];
        this.hasHit = false;
        this.explosionRadius = 80;
    }

    update() {
        if (!this.hasHit) {
            // Fall towards target
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.speed) {
                // Hit ground!
                this.hasHit = true;
                this.explode();
                return true; // Remove meteor after short delay
            }

            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
            this.rotation += 0.2;

            // Add trail particle
            this.trailParticles.push({
                x: this.x,
                y: this.y,
                life: 1
            });

            // Remove old trail particles
            this.trailParticles = this.trailParticles.filter(p => {
                p.life -= 0.05;
                return p.life > 0;
            });
        }

        return false;
    }

    explode() {
        // Create explosion effect
        createExplosionEffect(this.targetX, this.targetY, this.explosionRadius);
        createParticles(this.targetX, this.targetY, '#ff6600');

        // Damage all enemies in radius
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];
            const dist = Math.sqrt(
                Math.pow(enemy.x - this.targetX, 2) +
                Math.pow(enemy.y - this.targetY, 2)
            );

            if (dist < this.explosionRadius) {
                createParticles(enemy.x, enemy.y, '#ff4400');
                if (enemy.takeDamage(this.damage)) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(i, 1);
                }
            }
        }
    }

    draw() {
        // Draw trail
        this.trailParticles.forEach(p => {
            const screen = toScreen(p.x, p.y);
            ctx.fillStyle = `rgba(255, 100, 0, ${p.life * 0.6})`;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw meteor
        const screen = toScreen(this.x, this.y);

        ctx.save();
        ctx.translate(screen.x, screen.y);
        ctx.rotate(this.rotation);

        // Outer glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff6600';

        // Meteor body (rocky with flames)
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
        gradient.addColorStop(0, '#ffaa00');
        gradient.addColorStop(0.5, '#ff6600');
        gradient.addColorStop(1, '#cc3300');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Rock texture (darker spots)
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const radius = this.size * 0.6;
            ctx.fillStyle = 'rgba(100, 50, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(
                Math.cos(angle) * radius * 0.5,
                Math.sin(angle) * radius * 0.5,
                3, 0, Math.PI * 2
            );
            ctx.fill();
        }

        // Bright core
        ctx.fillStyle = '#ffff88';
        ctx.beginPath();
        ctx.arc(-2, -2, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// Chain Lightning - Jumps between enemies
class ChainLightning {
    constructor(startX, startY, weapon) {
        this.startX = startX;
        this.startY = startY;
        this.weapon = weapon;
        this.damage = weapon.damage;
        this.maxJumps = 5;
        this.jumpRange = 200;
        this.hitEnemies = new Set();
        this.chains = [];
        this.lifetime = 500; // 0.5 seconds
        this.spawnTime = Date.now();

        // Find initial target
        this.findChain(startX, startY);
    }

    findChain(fromX, fromY) {
        let closestEnemy = null;
        let closestDist = this.jumpRange;

        // Find closest enemy not yet hit
        gameState.enemies.forEach(enemy => {
            if (this.hitEnemies.has(enemy)) return;

            const dist = Math.sqrt(
                Math.pow(enemy.x - fromX, 2) +
                Math.pow(enemy.y - fromY, 2)
            );

            if (dist < closestDist) {
                closestDist = dist;
                closestEnemy = enemy;
            }
        });

        if (closestEnemy && this.chains.length < this.maxJumps) {
            this.chains.push({
                from: {x: fromX, y: fromY},
                to: {x: closestEnemy.x, y: closestEnemy.y},
                target: closestEnemy
            });
            this.hitEnemies.add(closestEnemy);

            // Damage enemy
            createParticles(closestEnemy.x, closestEnemy.y, '#00ffff');
            if (closestEnemy.takeDamage(this.damage)) {
                const index = gameState.enemies.indexOf(closestEnemy);
                if (index > -1) {
                    handleEnemyDeath(closestEnemy);
                    gameState.enemies.splice(index, 1);
                }
            }

            // Chain to next enemy
            this.findChain(closestEnemy.x, closestEnemy.y);
        }
    }

    update() {
        return Date.now() - this.spawnTime > this.lifetime;
    }

    draw() {
        const age = Date.now() - this.spawnTime;
        const alpha = 1 - (age / this.lifetime);

        this.chains.forEach(chain => {
            const from = toScreen(chain.from.x, chain.from.y);
            const to = toScreen(chain.to.x, chain.to.y);

            // Draw lightning bolt with jagged segments
            ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);

            // Create jagged lightning effect
            const segments = 5;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const x = from.x + (to.x - from.x) * t + (Math.random() - 0.5) * 20;
                const y = from.y + (to.y - from.y) * t + (Math.random() - 0.5) * 20;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // Bright core
            ctx.strokeStyle = `rgba(200, 255, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.shadowBlur = 0;
        });
    }
}

// Spirit Wolf - Summons wolves that attack enemies
class SpiritWolf {
    constructor(x, y, weapon) {
        this.x = x;
        this.y = y;
        this.weapon = weapon;
        this.size = 15;
        this.speed = 3;
        this.damage = weapon.damage;
        this.hp = 50;
        this.maxHp = 50;
        this.target = null;
        this.lifetime = 10000; // 10 seconds
        this.spawnTime = Date.now();
        this.attackCooldown = 0;
    }

    update() {
        // Check lifetime
        if (Date.now() - this.spawnTime > this.lifetime) {
            return true; // Remove
        }

        // Update attack cooldown
        if (this.attackCooldown > 0) {
            this.attackCooldown -= 16;
        }

        // Find target if none or target dead
        if (!this.target || !gameState.enemies.includes(this.target)) {
            let closestDist = Infinity;
            this.target = null;

            gameState.enemies.forEach(enemy => {
                const dist = Math.sqrt(
                    Math.pow(enemy.x - this.x, 2) +
                    Math.pow(enemy.y - this.y, 2)
                );
                if (dist < closestDist) {
                    closestDist = dist;
                    this.target = enemy;
                }
            });
        }

        // Move towards target
        if (this.target) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > this.size) {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }

            // Attack if close and cooldown ready
            if (dist < this.size + 20 && this.attackCooldown <= 0) {
                createParticles(this.target.x, this.target.y, '#8b5cf6');
                const isDead = this.target.takeDamage(this.damage);

                // Play magic sound for spirit wolf
                SoundSystem.playHit(isDead ? 'critical' : 'magic');

                if (isDead) {
                    const index = gameState.enemies.indexOf(this.target);
                    if (index > -1) {
                        handleEnemyDeath(this.target);
                        gameState.enemies.splice(index, 1);
                    }
                    this.target = null;
                }
                this.attackCooldown = 500; // 0.5 second cooldown
            }
        }

        return false;
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.save();

        // Ghost effect - pulsing transparency
        const alpha = 0.7 + Math.sin(Date.now() * 0.005) * 0.2;
        ctx.globalAlpha = alpha;

        // Glow effect
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#8b5cf6';

        // Load and draw the ghost wolf sprite
        if (!this.sprite) {
            this.sprite = new Image();
            this.sprite.src = 'assets/GhostWolfGame.png';
        }

        if (this.sprite.complete) {
            const spriteSize = this.size * 3; // Make it bigger than the old blob
            ctx.drawImage(
                this.sprite,
                screen.x - spriteSize / 2,
                screen.y - spriteSize / 2,
                spriteSize,
                spriteSize
            );
        } else {
            // Fallback circle while loading
            ctx.fillStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// Black Hole - Sucks in and damages enemies
class BlackHole {
    constructor(x, y, weapon) {
        this.x = x;
        this.y = y;
        this.weapon = weapon;
        this.size = 30;
        this.pullRadius = 250;
        this.damage = weapon.damage * 0.05; // Damage over time
        this.lifetime = 5000; // 5 seconds
        this.spawnTime = Date.now();
        this.rotation = 0;
    }

    update() {
        this.rotation += 0.1;

        // Check lifetime
        if (Date.now() - this.spawnTime > this.lifetime) {
            return true; // Remove
        }

        // Pull and damage enemies
        gameState.enemies.forEach((enemy, i) => {
            const dx = this.x - enemy.x;
            const dy = this.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.pullRadius) {
                // Pull enemy towards black hole
                const pullStrength = (1 - dist / this.pullRadius) * 0.8;
                enemy.x += (dx / dist) * pullStrength;
                enemy.y += (dy / dist) * pullStrength;

                // Damage if very close
                if (dist < this.size * 2) {
                    if (Math.random() < 0.1) {
                        createParticles(enemy.x, enemy.y, '#9900ff');
                    }

                    const isDead = enemy.takeDamage(this.damage);

                    // Play magic sound occasionally (to avoid spam from DoT)
                    if (Math.random() < 0.15) {
                        SoundSystem.playHit(isDead ? 'critical' : 'magic');
                    }

                    if (isDead) {
                        handleEnemyDeath(enemy);
                        gameState.enemies.splice(i, 1);
                    }
                }
            }
        });

        return false;
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Event horizon (outer ring)
        const gradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, this.size * 3);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
        gradient.addColorStop(0.3, 'rgba(50, 0, 100, 0.8)');
        gradient.addColorStop(0.6, 'rgba(100, 0, 200, 0.4)');
        gradient.addColorStop(1, 'rgba(100, 0, 200, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size * 3, 0, Math.PI * 2);
        ctx.fill();

        // Swirling particles
        for (let i = 0; i < 20; i++) {
            const angle = (i / 20) * Math.PI * 2 + this.rotation * (1 + i * 0.1);
            const radius = this.size + Math.sin(this.rotation * 3 + i) * this.size;
            const x = screen.x + Math.cos(angle) * radius;
            const y = screen.y + Math.sin(angle) * radius;

            const particleAlpha = 0.5 + Math.sin(this.rotation * 2 + i) * 0.3;
            ctx.fillStyle = `rgba(150, 50, 255, ${particleAlpha})`;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Black core
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Purple ring around core
        ctx.strokeStyle = 'rgba(150, 0, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#9900ff';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size * 1.2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

// Poison Cloud - Creates toxic clouds that damage enemies over time
class PoisonCloud {
    constructor(x, y, weapon) {
        this.x = x;
        this.y = y;
        this.weapon = weapon;
        this.size = 40;
        this.damageRadius = 80;
        this.damage = weapon.damage * 0.3; // DoT damage per tick
        this.lifetime = 6000; // 6 seconds
        this.spawnTime = Date.now();
        this.lastDamageTick = Date.now();
        this.damageCooldown = 500; // Damage every 0.5s
        this.pulsation = 0;
        this.damagedEnemies = new Set();
    }

    update() {
        const currentTime = Date.now();
        this.pulsation += 0.1;

        // Check lifetime
        if (currentTime - this.spawnTime > this.lifetime) {
            return true; // Remove
        }

        // Damage enemies in radius
        if (currentTime - this.lastDamageTick > this.damageCooldown) {
            this.damagedEnemies.clear();
            gameState.enemies.forEach((enemy, i) => {
                const dx = this.x - enemy.x;
                const dy = this.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.damageRadius && !this.damagedEnemies.has(i)) {
                    this.damagedEnemies.add(i);
                    createParticles(enemy.x, enemy.y, '#88ff00');

                    const isDead = enemy.takeDamage(this.damage);

                    if (Math.random() < 0.2) {
                        SoundSystem.playHit(isDead ? 'critical' : 'magic');
                    }

                    if (isDead) {
                        handleEnemyDeath(enemy);
                        gameState.enemies.splice(i, 1);
                    }
                }
            });
            this.lastDamageTick = currentTime;
        }

        return false;
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const pulse = Math.sin(this.pulsation) * 10;

        // Outer gas cloud
        const gradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, this.damageRadius + pulse);
        gradient.addColorStop(0, 'rgba(100, 255, 0, 0.6)');
        gradient.addColorStop(0.5, 'rgba(80, 200, 0, 0.3)');
        gradient.addColorStop(1, 'rgba(50, 150, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.damageRadius + pulse, 0, Math.PI * 2);
        ctx.fill();

        // Poison bubbles
        for (let i = 0; i < 15; i++) {
            const angle = (i / 15) * Math.PI * 2 + this.pulsation * 0.5;
            const radius = this.size + Math.sin(this.pulsation + i) * 20;
            const x = screen.x + Math.cos(angle) * radius;
            const y = screen.y + Math.sin(angle) * radius;

            ctx.fillStyle = `rgba(100, 255, 0, ${0.4 + Math.sin(this.pulsation * 2 + i) * 0.2})`;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Core
        ctx.fillStyle = 'rgba(80, 200, 0, 0.8)';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Crystal Shards - Exploding crystals that split into fragments
class CrystalShard {
    constructor(x, y, targetX, targetY, weapon, isFragment = false) {
        this.x = x;
        this.y = y;
        this.weapon = weapon;
        this.isFragment = isFragment;
        this.size = isFragment ? 8 : 15;
        this.speed = isFragment ? 4 : 6;
        this.damage = isFragment ? weapon.damage * 0.4 : weapon.damage;
        this.rotation = 0;
        this.rotationSpeed = 0.2;

        // Calculate direction
        const dx = targetX - x;
        const dy = targetY - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // Check world bounds
        if (this.x < 0 || this.x > CONFIG.world.width || this.y < 0 || this.y > CONFIG.world.height) {
            return true; // Remove
        }

        // Check collision with enemies
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < this.size + enemy.size) {
                createParticles(this.x, this.y, '#00ffff');

                const isDead = enemy.takeDamage(this.damage);
                SoundSystem.playHit(isDead ? 'critical' : 'normal');

                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(i, 1);
                }

                // If main shard hits, create fragments
                if (!this.isFragment) {
                    for (let j = 0; j < 4; j++) {
                        const angle = (j / 4) * Math.PI * 2;
                        const fragmentTarget = {
                            x: this.x + Math.cos(angle) * 200,
                            y: this.y + Math.sin(angle) * 200
                        };
                        gameState.crystalShards.push(new CrystalShard(
                            this.x, this.y, fragmentTarget.x, fragmentTarget.y, this.weapon, true
                        ));
                    }
                }

                return true; // Remove this shard
            }
        }

        return false;
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.save();
        ctx.translate(screen.x, screen.y);
        ctx.rotate(this.rotation);

        // Crystal glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffff';

        // Draw crystal shape
        ctx.fillStyle = this.isFragment ? '#00cccc' : '#00ffff';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;

        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const radius = i % 2 === 0 ? this.size : this.size * 0.6;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// Frost Nova - Freezes and damages all enemies around player
class FrostNova {
    constructor(weapon) {
        this.x = gameState.player.x;
        this.y = gameState.player.y;
        this.weapon = weapon;
        this.radius = 0;
        this.maxRadius = 200;
        this.expansionSpeed = 15;
        this.damage = weapon.damage;
        this.hitEnemies = new Set();
        this.freezeDuration = 2000; // Freeze enemies for 2s
    }

    update() {
        this.radius += this.expansionSpeed;

        // Check collision with enemies
        gameState.enemies.forEach((enemy, i) => {
            if (this.hitEnemies.has(i)) return;

            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist <= this.radius && dist < this.maxRadius) {
                this.hitEnemies.add(i);
                createParticles(enemy.x, enemy.y, '#00ffff');

                // Freeze enemy (slow them down)
                if (enemy.originalSpeed === undefined) {
                    enemy.originalSpeed = enemy.speed;
                }
                enemy.speed = enemy.originalSpeed * 0.2;
                enemy.frozenUntil = Date.now() + this.freezeDuration;

                const isDead = enemy.takeDamage(this.damage);
                SoundSystem.playHit(isDead ? 'critical' : 'magic');

                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(i, 1);
                }
            }
        });

        // Remove when fully expanded
        return this.radius >= this.maxRadius;
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Expanding frost ring
        const alpha = 1 - (this.radius / this.maxRadius);
        ctx.strokeStyle = `rgba(0, 200, 255, ${alpha})`;
        ctx.lineWidth = 8;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00ffff';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();

        // Inner glow
        ctx.strokeStyle = `rgba(200, 255, 255, ${alpha * 0.5})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.radius - 5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.shadowBlur = 0;
    }
}

// Thunder Hammer - Melee AOE attack with stun
class ThunderHammer {
    constructor(weapon) {
        this.x = gameState.player.x;
        this.y = gameState.player.y;
        this.weapon = weapon;
        this.size = 40;
        this.damageRadius = 120;
        this.damage = weapon.damage;
        this.lifetime = 400; // Short lived
        this.spawnTime = Date.now();
        this.hasHit = false;
        this.stunDuration = 1500; // Stun for 1.5s

        // Hammer appears in front of player
        const keys = gameState.keys;
        let hammerX = this.x;
        let hammerY = this.y;

        if (keys.w || keys.ArrowUp) hammerY -= 60;
        else if (keys.s || keys.ArrowDown) hammerY += 60;
        if (keys.a || keys.ArrowLeft) hammerX -= 60;
        else if (keys.d || keys.ArrowRight) hammerX += 60;

        this.targetX = hammerX;
        this.targetY = hammerY;
    }

    update() {
        const currentTime = Date.now();

        if (currentTime - this.spawnTime > this.lifetime) {
            return true; // Remove
        }

        // Damage enemies once
        if (!this.hasHit) {
            this.hasHit = true;

            gameState.enemies.forEach((enemy, i) => {
                const dx = this.targetX - enemy.x;
                const dy = this.targetY - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.damageRadius) {
                    createParticles(enemy.x, enemy.y, '#ffff00');

                    // Stun enemy
                    if (enemy.originalSpeed === undefined) {
                        enemy.originalSpeed = enemy.speed;
                    }
                    enemy.speed = 0;
                    enemy.stunnedUntil = currentTime + this.stunDuration;

                    const isDead = enemy.takeDamage(this.damage);
                    SoundSystem.playHit(isDead ? 'explosion' : 'critical');

                    if (isDead) {
                        handleEnemyDeath(enemy);
                        gameState.enemies.splice(i, 1);
                    }
                }
            });
        }

        return false;
    }

    draw() {
        const screen = toScreen(this.targetX, this.targetY);
        const progress = (Date.now() - this.spawnTime) / this.lifetime;

        // Lightning effect
        ctx.save();
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ffff00';

        // Hammer impact
        const impactRadius = this.damageRadius * (1 - progress);
        const alpha = 1 - progress;

        ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, impactRadius, 0, Math.PI * 2);
        ctx.stroke();

        // Lightning bolts
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const length = this.damageRadius * (1 - progress * 0.5);

            ctx.strokeStyle = `rgba(255, 255, 100, ${alpha * 0.8})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screen.x, screen.y);
            ctx.lineTo(
                screen.x + Math.cos(angle) * length,
                screen.y + Math.sin(angle) * length
            );
            ctx.stroke();
        }

        // Hammer (only visible at start)
        if (progress < 0.5) {
            const hammerAlpha = 1 - progress * 2;

            // Hammer head
            ctx.fillStyle = `rgba(150, 150, 150, ${hammerAlpha})`;
            ctx.fillRect(screen.x - 20, screen.y - 15, 40, 30);

            // Hammer glow
            ctx.fillStyle = `rgba(255, 255, 0, ${hammerAlpha * 0.5})`;
            ctx.fillRect(screen.x - 22, screen.y - 17, 44, 34);

            // Handle
            ctx.fillStyle = `rgba(101, 67, 33, ${hammerAlpha})`;
            ctx.fillRect(screen.x - 3, screen.y + 15, 6, 30);
        }

        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// Shadow Clone - Creates a clone that mimics player attacks
class ShadowClone {
    constructor(weapon) {
        this.weapon = weapon;
        this.x = gameState.player.x;
        this.y = gameState.player.y;
        this.offsetX = (Math.random() - 0.5) * 100;
        this.offsetY = (Math.random() - 0.5) * 100;
        this.size = 30;
        this.lifetime = 10000; // 10 seconds
        this.spawnTime = Date.now();
        this.attackCooldown = 1000;
        this.lastAttack = Date.now();
        this.alpha = 0;
        this.fadeInDuration = 500;
    }

    update() {
        const currentTime = Date.now();
        const age = currentTime - this.spawnTime;

        // Fade in
        if (age < this.fadeInDuration) {
            this.alpha = age / this.fadeInDuration;
        } else {
            this.alpha = 1;
        }

        // Check lifetime
        if (age > this.lifetime) {
            return true; // Remove
        }

        // Follow player with offset
        const targetX = gameState.player.x + this.offsetX;
        const targetY = gameState.player.y + this.offsetY;
        this.x += (targetX - this.x) * 0.1;
        this.y += (targetY - this.y) * 0.1;

        // Attack nearest enemy
        if (currentTime - this.lastAttack > this.attackCooldown) {
            let nearestEnemy = null;
            let nearestDist = 300;

            gameState.enemies.forEach(enemy => {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy) {
                // Create shadow projectile
                gameState.projectiles.push(new Projectile(
                    this.x,
                    this.y,
                    nearestEnemy.x,
                    nearestEnemy.y,
                    { ...this.weapon, type: 'shadow_bolt', damage: this.weapon.damage * 0.5 }
                ));
                this.lastAttack = currentTime;
            }
        }

        return false;
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.save();

        // Shadow effect - more transparent and darker
        ctx.globalAlpha = this.alpha * 0.4;
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#000088';

        // Draw player sprite but darker/shadow version
        if (gameState.player.sprite && gameState.player.sprite.complete) {
            const spriteX = gameState.player.spriteX || 0;
            const spriteY = gameState.player.spriteY || 0;
            const spriteSize = gameState.player.spriteSize || 64;

            // Apply dark tint for shadow effect
            ctx.filter = 'brightness(0.3) saturate(0.5) hue-rotate(240deg)';

            ctx.drawImage(
                gameState.player.sprite,
                spriteX, spriteY,
                spriteSize, spriteSize,
                screen.x - this.size,
                screen.y - this.size,
                this.size * 2,
                this.size * 2
            );

            ctx.filter = 'none';
        } else {
            // Fallback to circle if sprite not loaded
            ctx.fillStyle = '#220066';
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// Sword Spin Class - Player spins with a sword doing AOE damage
class SwordSpinAttack {
    constructor(weapon) {
        this.damage = weapon.damage;
        this.weapon = weapon;
        this.isActive = false;
        this.spinAngle = 0;
        this.spinDuration = 800; // How long the spin lasts (ms)
        this.spinStartTime = 0;
        this.spinRadius = 80; // Damage radius
        this.hitEnemies = new Set(); // Track which enemies we've hit this spin
    }

    activate() {
        if (!this.isActive) {
            this.isActive = true;
            this.spinStartTime = Date.now();
            this.spinAngle = 0;
            this.hitEnemies.clear();
        }
    }

    update() {
        if (!this.isActive) return false;

        const currentTime = Date.now();
        const elapsed = currentTime - this.spinStartTime;

        if (elapsed >= this.spinDuration) {
            this.isActive = false;
            return false;
        }

        // Spin faster at the beginning, slower at end
        const progress = elapsed / this.spinDuration;
        this.spinAngle += (1 - progress * 0.5) * 0.4; // Starts fast, slows down

        // Check collision with all enemies in radius
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            if (this.hitEnemies.has(i)) continue;

            const enemy = gameState.enemies[i];
            const dist = Math.sqrt(
                Math.pow(enemy.x - gameState.player.x, 2) +
                Math.pow(enemy.y - gameState.player.y, 2)
            );

            if (dist < this.spinRadius + enemy.size) {
                this.hitEnemies.add(i);
                createParticles(enemy.x, enemy.y, '#c0c0c0');

                const isDead = enemy.takeDamage(this.damage);

                // Play sword hit sound
                SoundSystem.playHit(isDead ? 'critical' : 'normal');

                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(i, 1);
                    // Update hit enemies set
                    const newSet = new Set();
                    this.hitEnemies.forEach(idx => {
                        if (idx > i) newSet.add(idx - 1);
                        else if (idx < i) newSet.add(idx);
                    });
                    this.hitEnemies = newSet;
                }
            }
        }

        return true;
    }

    draw() {
        if (!this.isActive) return;

        const playerScreen = toScreen(gameState.player.x, gameState.player.y);
        const elapsed = Date.now() - this.spinStartTime;
        const progress = elapsed / this.spinDuration;

        ctx.save();
        ctx.translate(playerScreen.x, playerScreen.y);

        // Draw spinning motion blur circle
        const blurAlpha = 0.3 * (1 - progress);
        ctx.strokeStyle = `rgba(192, 192, 192, ${blurAlpha})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 0, this.spinRadius, 0, Math.PI * 2);
        ctx.stroke();

        // Draw multiple sword trails for motion blur effect
        const numTrails = 8;
        for (let i = 0; i < numTrails; i++) {
            const trailAngle = this.spinAngle - (i * 0.3);
            const trailAlpha = (1 - i / numTrails) * 0.4 * (1 - progress);

            ctx.save();
            ctx.rotate(trailAngle);

            // Sword trail
            const swordLength = 60;
            ctx.strokeStyle = `rgba(200, 200, 255, ${trailAlpha})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(swordLength, 0);
            ctx.stroke();

            ctx.restore();
        }

        // Draw main sword
        ctx.rotate(this.spinAngle);

        const swordLength = 60;
        const swordWidth = 12;

        // Sword glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';

        // Blade
        ctx.fillStyle = '#d0d0d0';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -swordWidth / 2);
        ctx.lineTo(swordLength - 10, -swordWidth / 3);
        ctx.lineTo(swordLength, 0); // Sharp tip
        ctx.lineTo(swordLength - 10, swordWidth / 3);
        ctx.lineTo(0, swordWidth / 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Blade shine
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.moveTo(5, -swordWidth / 4);
        ctx.lineTo(swordLength - 15, -swordWidth / 6);
        ctx.lineTo(swordLength - 15, swordWidth / 6);
        ctx.lineTo(5, swordWidth / 4);
        ctx.closePath();
        ctx.fill();

        // Handle
        ctx.fillStyle = '#654321';
        ctx.fillRect(-15, -swordWidth / 2, 15, swordWidth);

        // Cross guard
        ctx.fillStyle = '#b8860b';
        ctx.fillRect(-5, -swordWidth * 1.2, 5, swordWidth * 2.4);

        // Pommel
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(-15, 0, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// Projectile Class
class Projectile {
    constructor(x, y, targetX, targetY, weapon) {
        this.x = x;
        this.y = y;
        this.size = 5;
        this.speed = 8;
        this.damage = weapon.damage;
        this.range = weapon.range;
        this.distanceTraveled = 0;
        this.weapon = weapon;

        // Calculate direction
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.vx = (dx / distance) * this.speed;
        this.vy = (dy / distance) * this.speed;

        // Trail effect for magic missile
        this.trail = [];
        this.maxTrailLength = 8;
    }

    update() {
        // Add current position to trail
        if (this.weapon.type === 'magic_missile') {
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > this.maxTrailLength) {
                this.trail.shift();
            }
        }

        this.x += this.vx;
        this.y += this.vy;
        this.distanceTraveled += this.speed;

        // Check collision with enemies
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
            const enemy = gameState.enemies[i];
            const dist = Math.sqrt(
                Math.pow(this.x - enemy.x, 2) +
                Math.pow(this.y - enemy.y, 2)
            );

            if (dist < enemy.size + this.size) {
                this.handleHit(enemy, i);
                return true; // Projectile hit (except lightning which chains)
            }
        }

        return this.distanceTraveled > this.range;
    }

    handleHit(enemy, enemyIndex) {
        // Calculate critical hit
        const isCrit = Math.random() < gameState.critChance;
        const finalDamage = isCrit ? this.damage * gameState.critMultiplier : this.damage;

        // Show damage number
        gameState.damageNumbers.push(new DamageNumber(enemy.x, enemy.y, finalDamage, isCrit));

        // Deal damage
        const isDead = enemy.takeDamage(finalDamage);

        // Critical hit visual effect
        if (isCrit) {
            // Extra particles for crits
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                gameState.particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    size: 2 + Math.random() * 2,
                    color: '#ffd700',
                    alpha: 1,
                    gravity: 0,
                    life: 1,
                    draw: function() {
                        const screen = toScreen(this.x, this.y);
                        ctx.save();
                        ctx.globalAlpha = this.alpha;
                        ctx.fillStyle = this.color;
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#ffd700';
                        ctx.fillRect(screen.x - this.size/2, screen.y - this.size/2, this.size, this.size);
                        ctx.restore();
                    },
                    update: function() {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.vx *= 0.95;
                        this.vy *= 0.95;
                        this.life -= 0.02;
                        this.alpha = this.life;
                    }
                });
            }
        }

        // Play weapon-specific hit sound
        let soundType = isCrit ? 'critical' : 'normal';
        if (isDead) {
            soundType = 'critical';
        } else if (this.weapon.type === 'fireball' || this.weapon.type === 'meteor') {
            soundType = 'explosion';
        } else if (this.weapon.type === 'ice' || this.weapon.type === 'frost_nova') {
            soundType = 'magic';
        } else if (this.weapon.type === 'lightning' || this.weapon.type === 'chain_lightning') {
            soundType = 'magic';
        } else if (this.weapon.type === 'arcane_orb' || this.weapon.type === 'spirit') {
            soundType = 'magic';
        }
        SoundSystem.playHit(soundType);

        // Weapon-specific effects
        switch(this.weapon.type) {
            case 'lightning':
                // Chain lightning - jump to multiple nearby enemies
                createParticles(enemy.x, enemy.y, '#ffff00');
                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(enemyIndex, 1);
                }

                // Recursive chain lightning
                const maxChains = 5; // Number of times it can chain
                const chainRange = 150; // Range to find next target
                let currentTarget = enemy;
                let hitTargets = new Set([enemyIndex]);
                let chainDamage = this.damage * 0.6;

                for (let chain = 0; chain < maxChains; chain++) {
                    let closestDist = chainRange;
                    let nextTarget = null;
                    let nextIndex = -1;

                    // Find closest enemy not yet hit
                    for (let j = 0; j < gameState.enemies.length; j++) {
                        if (hitTargets.has(j)) continue;
                        const nextEnemy = gameState.enemies[j];
                        const dist = Math.sqrt(
                            Math.pow(nextEnemy.x - currentTarget.x, 2) +
                            Math.pow(nextEnemy.y - currentTarget.y, 2)
                        );
                        if (dist < closestDist) {
                            closestDist = dist;
                            nextTarget = nextEnemy;
                            nextIndex = j;
                        }
                    }

                    if (!nextTarget) break; // No more targets in range

                    // Create lightning effect
                    createLightningEffect(currentTarget.x, currentTarget.y, nextTarget.x, nextTarget.y);

                    // Damage and particles
                    const chainIsDead = nextTarget.takeDamage(chainDamage);
                    createParticles(nextTarget.x, nextTarget.y, '#ffff00');

                    if (chainIsDead) {
                        handleEnemyDeath(nextTarget);
                        gameState.enemies.splice(nextIndex, 1);
                        // Update indices after removal
                        const updatedHitTargets = new Set();
                        hitTargets.forEach(idx => {
                            updatedHitTargets.add(idx > nextIndex ? idx - 1 : idx);
                        });
                        hitTargets = updatedHitTargets;
                        break; // Stop chaining if enemy died
                    }

                    hitTargets.add(nextIndex);
                    currentTarget = nextTarget;
                    chainDamage *= 0.85; // Slightly reduce damage each chain
                }
                break;

            case 'fireball':
                // Explosion - damage all nearby enemies
                createParticles(enemy.x, enemy.y, '#ff4500');
                const explosionRadius = this.weapon.explosionRadius || 50;

                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const nearbyEnemy = gameState.enemies[j];
                    const explosionDist = Math.sqrt(
                        Math.pow(nearbyEnemy.x - enemy.x, 2) +
                        Math.pow(nearbyEnemy.y - enemy.y, 2)
                    );

                    if (explosionDist < explosionRadius) {
                        const splashDamage = j === enemyIndex ? this.damage : this.damage * 0.6;
                        if (nearbyEnemy.takeDamage(splashDamage)) {
                            handleEnemyDeath(nearbyEnemy);
                            gameState.enemies.splice(j, 1);
                            if (j < enemyIndex) enemyIndex--; // Adjust index
                        }
                    }
                }

                // Draw explosion ring
                createExplosionEffect(enemy.x, enemy.y, explosionRadius);
                break;

            case 'ice':
                // Slow effect
                enemy.slowedUntil = Date.now() + 2000; // Slow for 2 seconds
                createParticles(enemy.x, enemy.y, '#00ffff');

                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(enemyIndex, 1);
                }
                break;

            case 'arcane':
                // Standard hit with purple particles
                createParticles(enemy.x, enemy.y, '#9370db');
                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(enemyIndex, 1);
                }
                break;

            default: // magic_missile
                createParticles(enemy.x, enemy.y, '#00d9ff');
                if (isDead) {
                    handleEnemyDeath(enemy);
                    gameState.enemies.splice(enemyIndex, 1);
                }
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Magic missile uses custom sprite with rotation
        if (this.weapon.type === 'magic_missile') {
            const projectileImg = new Image();
            projectileImg.src = '/assets/MagicOrbProjectileBasicGame.png';

            // Calculate angle based on velocity direction
            const angle = Math.atan2(this.vy, this.vx);

            ctx.save();
            ctx.translate(screen.x, screen.y);
            ctx.rotate(angle);

            // Add glow effect
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#a855f7';

            // Draw projectile image (centered)
            const size = 40; // Size of the sprite
            ctx.drawImage(projectileImg, -size/2, -size/2, size, size);

            ctx.restore();
            ctx.shadowBlur = 0;
            return;
        }

        // Different colors and effects for other weapon types
        let fillColor, glowColor, size;

        switch(this.weapon.type) {
            case 'lightning':
                fillColor = '#ffff00';
                glowColor = '#ffff99';
                size = 7;
                // Electric spark effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                break;
            case 'fireball':
                fillColor = '#ff4500';
                glowColor = '#ff8c00';
                size = 10;
                // Flame trail
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff4500';
                break;
            case 'ice':
                fillColor = '#00ffff';
                glowColor = '#b0e0e6';
                size = 6;
                // Frost effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ffff';
                break;
            case 'arcane':
                fillColor = '#9370db';
                glowColor = '#ba55d3';
                size = 8;
                // Magic shimmer
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#9370db';
                break;
            default:
                fillColor = '#00d9ff';
                glowColor = '#7fffd4';
                size = 5;
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#00d9ff';
        }

        // Draw simple circle projectile for other types
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, size, 0, Math.PI * 2);
        ctx.fill();

        // Glow effect
        ctx.strokeStyle = glowColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Reset shadow
        ctx.shadowBlur = 0;
    }
}

// Orbiting Orb Class
class OrbitingOrb {
    constructor(index, totalOrbs, weapon) {
        this.index = index;
        this.totalOrbs = totalOrbs;
        this.weapon = weapon;
        this.angle = (Math.PI * 2 / totalOrbs) * index; // Evenly space orbs
        this.orbitRadius = 80;
        this.rotationSpeed = 0.05; // Radians per frame
        this.size = 10;
        this.damage = weapon.damage;
        this.lastHitTime = 0;
        this.hitCooldown = 500; // ms between hits on same enemy
    }

    update(currentTime) {
        // Rotate around player
        this.angle += this.rotationSpeed;

        // Calculate position
        this.x = gameState.player.x + Math.cos(this.angle) * this.orbitRadius;
        this.y = gameState.player.y + Math.sin(this.angle) * this.orbitRadius;

        // Check collision with enemies
        if (currentTime - this.lastHitTime > this.hitCooldown) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                const dist = Math.sqrt(
                    Math.pow(this.x - enemy.x, 2) +
                    Math.pow(this.y - enemy.y, 2)
                );

                if (dist < enemy.size + this.size) {
                    // Hit enemy
                    createParticles(enemy.x, enemy.y, '#9370db');
                    const isDead = enemy.takeDamage(this.damage);

                    // Play magic hit sound for orbs
                    SoundSystem.playHit(isDead ? 'critical' : 'magic');

                    if (isDead) {
                        handleEnemyDeath(enemy);
                        gameState.enemies.splice(i, 1);
                    }
                    this.lastHitTime = currentTime;
                    break; // Only hit one enemy per update
                }
            }
        }
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        // Purple orb with glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#9370db';

        ctx.fillStyle = '#9370db';
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Outer glow
        ctx.strokeStyle = '#ba55d3';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Inner shine
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(screen.x - 3, screen.y - 3, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
    }
}

// Particle Class for effects
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.size = Math.random() * 5 + 2;
        this.life = 1;
        this.color = color;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
        this.size *= 0.95;
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// XP Orb class
class XPOrb {
    constructor(x, y, xpValue = 5) {
        this.x = x;
        this.y = y;
        this.xpValue = xpValue;

        // Size and color based on XP value
        if (xpValue <= 5) {
            // Small XP (common enemies)
            this.size = 6;
            this.color = { r: 100, g: 200, b: 255 }; // Blue
        } else if (xpValue <= 15) {
            // Medium XP
            this.size = 9;
            this.color = { r: 150, g: 100, b: 255 }; // Purple
        } else if (xpValue <= 30) {
            // Large XP
            this.size = 12;
            this.color = { r: 255, g: 150, b: 50 }; // Orange
        } else {
            // Huge XP (bosses)
            this.size = 16;
            this.color = { r: 255, g: 215, b: 0 }; // Gold
        }

        this.magnetRange = 150; // How close player needs to be to attract orb
        this.magnetSpeed = 4;
        this.pulseTimer = 0;
        this.glowIntensity = 0;
        this.rotation = Math.random() * Math.PI * 2; // Random start rotation
        this.rotationSpeed = 0.05;
        this.floatOffset = Math.random() * Math.PI * 2; // Random float phase
        this.sparkles = []; // Particle sparkles around orb
        this.age = 0;
    }

    update() {
        this.age++;

        // Calculate distance to player
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Magnetic pull when player is close (only if player has XP magnet upgrade)
        if (gameState.player.hasXPMagnet && dist < this.magnetRange) {
            const pullStrength = 1 - (dist / this.magnetRange);
            this.x += (dx / dist) * this.magnetSpeed * pullStrength;
            this.y += (dy / dist) * this.magnetSpeed * pullStrength;
        }

        // Check if player collects the orb (must touch it without magnet)
        if (dist < CONFIG.player.size + this.size) {
            return true; // Signal for removal and XP gain
        }

        // Update animations
        this.pulseTimer += 0.1;
        this.glowIntensity = Math.sin(this.pulseTimer) * 0.3 + 0.7;
        this.rotation += this.rotationSpeed;
        this.floatOffset += 0.08;

        // Add sparkle particles occasionally
        if (Math.random() < 0.15) {
            const angle = Math.random() * Math.PI * 2;
            const distance = this.size * 0.8;
            this.sparkles.push({
                x: this.x + Math.cos(angle) * distance,
                y: this.y + Math.sin(angle) * distance,
                vx: Math.cos(angle) * 0.5,
                vy: Math.sin(angle) * 0.5 - 0.3,
                life: 1,
                size: 1 + Math.random() * 1.5
            });
        }

        // Update sparkles
        this.sparkles = this.sparkles.filter(sparkle => {
            sparkle.x += sparkle.vx;
            sparkle.y += sparkle.vy;
            sparkle.vy += 0.02; // Gravity
            sparkle.life -= 0.03;
            return sparkle.life > 0;
        });

        return false;
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const floatY = Math.sin(this.floatOffset) * 3; // Floating effect

        ctx.save();

        // Draw sparkles first (behind orb)
        this.sparkles.forEach(sparkle => {
            const sparkleScreen = toScreen(sparkle.x, sparkle.y);
            ctx.globalAlpha = sparkle.life;
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 4;
            ctx.shadowColor = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
            ctx.fillRect(
                sparkleScreen.x - sparkle.size / 2,
                sparkleScreen.y - sparkle.size / 2,
                sparkle.size,
                sparkle.size
            );
        });
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;

        // Outer pulsing glow
        const gradient = ctx.createRadialGradient(
            screen.x,
            screen.y + floatY,
            0,
            screen.x,
            screen.y + floatY,
            this.size * 2.5
        );
        gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.glowIntensity * 0.6})`);
        gradient.addColorStop(0.4, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.glowIntensity * 0.3})`);
        gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y + floatY, this.size * 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Rotating energy ring
        ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.glowIntensity * 0.5})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = this.rotation + (Math.PI * 2 / 8) * i;
            const ringRadius = this.size * 1.3;
            const x = screen.x + Math.cos(angle) * ringRadius;
            const y = screen.y + floatY + Math.sin(angle) * ringRadius;

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        ctx.stroke();

        // Main orb body with better gradient
        const currentSize = this.size * (0.9 + Math.sin(this.pulseTimer) * 0.1);
        const orbGradient = ctx.createRadialGradient(
            screen.x - currentSize * 0.4,
            screen.y + floatY - currentSize * 0.4,
            0,
            screen.x,
            screen.y + floatY,
            currentSize
        );

        // Create lighter versions of the color for gradient
        const lightColor = `rgb(${Math.min(255, this.color.r + 100)}, ${Math.min(255, this.color.g + 100)}, ${Math.min(255, this.color.b + 100)})`;
        const midColor = `rgb(${Math.min(255, this.color.r + 50)}, ${Math.min(255, this.color.g + 50)}, ${Math.min(255, this.color.b + 50)})`;
        const darkColor = `rgb(${Math.max(0, this.color.r - 50)}, ${Math.max(0, this.color.g - 50)}, ${Math.max(0, this.color.b - 50)})`;

        orbGradient.addColorStop(0, '#ffffff');
        orbGradient.addColorStop(0.3, lightColor);
        orbGradient.addColorStop(0.6, midColor);
        orbGradient.addColorStop(1, darkColor);

        ctx.shadowBlur = 15;
        ctx.shadowColor = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
        ctx.fillStyle = orbGradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y + floatY, currentSize, 0, Math.PI * 2);
        ctx.fill();

        // Inner core
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = this.glowIntensity * 0.7;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y + floatY, currentSize * 0.4, 0, Math.PI * 2);
        ctx.fill();

        // Highlight shine
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(
            screen.x - currentSize * 0.35,
            screen.y + floatY - currentSize * 0.35,
            currentSize * 0.25,
            0,
            Math.PI * 2
        );
        ctx.fill();

        ctx.restore();
    }
}

// Damage Number class - floating combat text
class DamageNumber {
    constructor(x, y, damage, isCrit = false) {
        this.x = x;
        this.y = y;
        this.damage = Math.floor(damage);
        this.isCrit = isCrit;
        this.life = 1;
        this.vy = -2; // Float upward
        this.vx = (Math.random() - 0.5) * 1; // Slight horizontal drift
        this.scale = 1;
        this.rotation = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.05; // Slight gravity
        this.life -= 0.015;

        return this.life <= 0; // Return true when should be removed
    }

    draw() {
        const screen = toScreen(this.x, this.y);

        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(screen.x, screen.y);

        // Shadow/outline for readability
        ctx.font = this.isCrit ? 'bold 22px "Courier New"' : 'bold 16px "Courier New"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Outline
        ctx.strokeStyle = '#000';
        ctx.lineWidth = this.isCrit ? 4 : 3;
        ctx.strokeText(this.damage, 0, 0);

        // Fill
        if (this.isCrit) {
            // Critical - red
            ctx.fillStyle = '#ff4444';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ff0000';
        } else {
            // Normal - white
            ctx.fillStyle = '#ffffff';
        }

        ctx.fillText(this.damage, 0, 0);

        ctx.restore();
    }
}

// Chest class
class Chest {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 20;
        this.coinValue = Math.floor(Math.random() * 50) + 20; // 20-70 coins
        this.bobTimer = Math.random() * Math.PI * 2; // Random start for bob animation
        this.glowIntensity = 0;
        this.isNearPlayer = false;
    }

    update() {
        // Calculate distance to player
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Check if player is near
        this.isNearPlayer = dist < 50;

        // Update bob animation
        this.bobTimer += 0.05;
        this.glowIntensity = Math.sin(this.bobTimer) * 0.3 + 0.7;

        return false; // Chests don't get auto-collected
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const bobOffset = Math.sin(this.bobTimer) * 5;
        const sparklePhase = this.bobTimer * 3;

        // Chest sprite size
        const spriteSize = 64; // Adjust based on your sprite size

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y + spriteSize * 0.4, spriteSize * 0.4, spriteSize * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Magical glow if player is near
        if (this.isNearPlayer) {
            // Outer magical glow
            const outerGlow = ctx.createRadialGradient(screen.x, screen.y + bobOffset, 0, screen.x, screen.y + bobOffset, spriteSize * 1.5);
            outerGlow.addColorStop(0, `rgba(255, 215, 0, ${this.glowIntensity * 0.4})`);
            outerGlow.addColorStop(0.3, `rgba(255, 165, 0, ${this.glowIntensity * 0.3})`);
            outerGlow.addColorStop(0.6, `rgba(218, 165, 32, ${this.glowIntensity * 0.1})`);
            outerGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y + bobOffset, spriteSize * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Inner bright glow
            const innerGlow = ctx.createRadialGradient(screen.x, screen.y + bobOffset, 0, screen.x, screen.y + bobOffset, spriteSize * 0.8);
            innerGlow.addColorStop(0, `rgba(255, 255, 200, ${this.glowIntensity * 0.6})`);
            innerGlow.addColorStop(0.5, `rgba(255, 215, 0, ${this.glowIntensity * 0.3})`);
            innerGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y + bobOffset, spriteSize * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw the chest sprite
        ctx.save();
        ctx.imageSmoothingEnabled = false; // Pixel art style
        ctx.drawImage(
            rewardChestSprite,
            screen.x - spriteSize / 2,
            screen.y + bobOffset - spriteSize / 2,
            spriteSize,
            spriteSize
        );
        ctx.restore();

        // Sparkle effects when near player
        if (this.isNearPlayer) {
            ctx.fillStyle = '#FFE87C';
            for (let i = 0; i < 5; i++) {
                const sparkleAngle = sparklePhase + (i * Math.PI * 2 / 5);
                const sparkleDistance = spriteSize * 0.6;
                const sparkleSize = 2 + Math.sin(sparklePhase + i) * 1.5;
                const sparkleX = screen.x + Math.cos(sparkleAngle) * sparkleDistance;
                const sparkleY = screen.y + bobOffset + Math.sin(sparkleAngle) * sparkleDistance;

                ctx.save();
                ctx.translate(sparkleX, sparkleY);
                ctx.rotate(sparklePhase + i);
                ctx.beginPath();
                ctx.moveTo(0, -sparkleSize);
                ctx.lineTo(sparkleSize * 0.3, 0);
                ctx.lineTo(0, sparkleSize);
                ctx.lineTo(-sparkleSize * 0.3, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // Interaction prompt with better styling
        if (this.isNearPlayer) {
            // Prompt background with gradient
            const promptGradient = ctx.createLinearGradient(
                screen.x - 40,
                screen.y - spriteSize * 0.8 + bobOffset,
                screen.x + 40,
                screen.y - spriteSize * 0.8 + bobOffset + 26
            );
            promptGradient.addColorStop(0, 'rgba(20, 20, 30, 0.85)');
            promptGradient.addColorStop(0.5, 'rgba(30, 30, 40, 0.95)');
            promptGradient.addColorStop(1, 'rgba(20, 20, 30, 0.85)');
            ctx.fillStyle = promptGradient;

            // Rounded rectangle for prompt
            ctx.beginPath();
            ctx.roundRect(screen.x - 40, screen.y - spriteSize * 0.8 + bobOffset, 80, 26, 8);
            ctx.fill();

            // Border glow
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Text with glow
            ctx.save();
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#FFD700';
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Press E', screen.x, screen.y - spriteSize * 0.8 + bobOffset + 13);
            ctx.restore();
        }
    }
}

// Mystery Box Drop class - dropped from enemies during gameplay
class MysteryBoxDrop {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 25;
        this.bobTimer = Math.random() * Math.PI * 2;
        this.glowIntensity = 0;
        this.isNearPlayer = false;
        this.rotationAngle = 0;
    }

    update() {
        // Calculate distance to player
        const dx = gameState.player.x - this.x;
        const dy = gameState.player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Check if player is near
        this.isNearPlayer = dist < 50;

        // Update animations
        this.bobTimer += 0.05;
        this.rotationAngle += 0.02;
        this.glowIntensity = Math.sin(this.bobTimer) * 0.3 + 0.7;

        return false; // Mystery boxes don't get auto-collected
    }

    draw() {
        const screen = toScreen(this.x, this.y);
        const bobOffset = Math.sin(this.bobTimer) * 7;

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y + this.size * 1.5, this.size * 1.3, this.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Rainbow glow if player is near
        if (this.isNearPlayer) {
            const rainbow = ['#FFD700', '#FF1493', '#00CED1', '#9370DB', '#FFD700'];
            const glowPhase = this.bobTimer * 2;

            for (let i = 0; i < 5; i++) {
                const phase = (glowPhase + i * 0.4) % rainbow.length;
                const colorIndex = Math.floor(phase);
                const color = rainbow[colorIndex];

                const glow = ctx.createRadialGradient(screen.x, screen.y + bobOffset, 0, screen.x, screen.y + bobOffset, this.size * (4 - i * 0.5));
                glow.addColorStop(0, `${color}${Math.floor(this.glowIntensity * 100).toString(16).padStart(2, '0')}`);
                glow.addColorStop(0.5, `${color}33`);
                glow.addColorStop(1, `${color}00`);
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y + bobOffset, this.size * (4 - i * 0.5), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.save();
        ctx.translate(screen.x, screen.y + bobOffset);
        ctx.rotate(Math.sin(this.rotationAngle) * 0.1);

        // Box main body with gradient (golden)
        const boxGradient = ctx.createLinearGradient(-this.size, -this.size, this.size, this.size);
        boxGradient.addColorStop(0, '#FFD700');
        boxGradient.addColorStop(0.3, '#FFA500');
        boxGradient.addColorStop(0.7, '#FFD700');
        boxGradient.addColorStop(1, '#FF8C00');
        ctx.fillStyle = boxGradient;
        ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);

        // Box border
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.strokeRect(-this.size, -this.size, this.size * 2, this.size * 2);

        // Question mark
        ctx.fillStyle = '#8B4513';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('?', 0, 0);

        // Sparkles around box
        const sparkleCount = 6;
        for (let i = 0; i < sparkleCount; i++) {
            const angle = (this.rotationAngle * 2 + (i / sparkleCount) * Math.PI * 2);
            const sparkleX = Math.cos(angle) * this.size * 1.8;
            const sparkleY = Math.sin(angle) * this.size * 1.8;
            const sparkleSize = 3 + Math.sin(this.bobTimer * 3 + i) * 2;

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();

        // Interaction prompt
        if (this.isNearPlayer) {
            const promptGradient = ctx.createLinearGradient(
                screen.x - 50,
                screen.y - this.size * 2.8 + bobOffset,
                screen.x + 50,
                screen.y - this.size * 2.8 + bobOffset + 26
            );
            promptGradient.addColorStop(0, 'rgba(20, 20, 30, 0.85)');
            promptGradient.addColorStop(0.5, 'rgba(30, 30, 40, 0.95)');
            promptGradient.addColorStop(1, 'rgba(20, 20, 30, 0.85)');
            ctx.fillStyle = promptGradient;

            ctx.beginPath();
            ctx.roundRect(screen.x - 50, screen.y - this.size * 2.8 + bobOffset, 100, 26, 8);
            ctx.fill();

            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.save();
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#FFD700';
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Press E to Spin!', screen.x, screen.y - this.size * 2.8 + bobOffset + 13);
            ctx.restore();
        }
    }
}

// Handle enemy death - spawn XP orb and maybe chest
function handleEnemyDeath(enemy) {
    // Calculate XP based on enemy type and difficulty
    let xpValue = 3; // Base XP for normal enemy (goblin)

    if (enemy.isMajorBoss) {
        xpValue = 100; // Major boss gives huge XP
    } else if (enemy.isBoss) {
        xpValue = 50; // Boss gives lots of XP
    } else if (enemy.maxHp >= 50) {
        xpValue = 8; // Ghost (50 HP) - medium XP
    } else if (enemy.maxHp >= 40) {
        xpValue = 6; // Orc (40 HP) - slightly more XP
    } else {
        xpValue = 3; // Goblin (30 HP) - base XP
    }

    gameState.xpOrbs.push(new XPOrb(enemy.x, enemy.y, xpValue));

    // 5% chance to drop a chest
    if (Math.random() < 0.05) {
        gameState.chests.push(new Chest(enemy.x, enemy.y));
    }

    // 2% chance to drop a Mystery Box (rarer than chests!)
    if (Math.random() < 0.02) {
        gameState.mysteryBoxes = gameState.mysteryBoxes || [];
        gameState.mysteryBoxes.push(new MysteryBoxDrop(enemy.x, enemy.y));
    }

    // CREATE AWESOME DEATH EXPLOSION!
    // Use enemy's own color palette if available, otherwise default green
    const enemyColorPalette = enemy.colorPalette || ['#4a9d5f', '#5fb571', '#6ed47f', '#3d8a4f', '#7be58d'];
    createDeathExplosion(enemy.x, enemy.y, enemy.isBoss || enemy.isMajorBoss, enemyColorPalette);

    // Call onDeath handler if enemy has one (e.g., Splitter splits)
    if (enemy.onDeath) {
        enemy.onDeath();
    }

    gameState.kills++;
}

// Create particles
function createParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
        gameState.particles.push(new Particle(x, y, color));
    }
}

// Lightning effect between two points
function createLightningEffect(x1, y1, x2, y2) {
    gameState.particles.push({
        type: 'lightning',
        x1, y1, x2, y2,
        life: 1.5, // Much longer duration to see all chains
        maxLife: 1.5,
        draw: function() {
            const screen1 = toScreen(this.x1, this.y1);
            const screen2 = toScreen(this.x2, this.y2);

            // Main lightning bolt (bright yellow)
            const alpha = Math.min(this.life * 0.9, 1);
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(screen1.x, screen1.y);

            // Jagged lightning effect
            const segments = 5;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const worldX = this.x1 + (this.x2 - this.x1) * t + (Math.random() - 0.5) * 25;
                const worldY = this.y1 + (this.y2 - this.y1) * t + (Math.random() - 0.5) * 25;
                const screenPoint = toScreen(worldX, worldY);
                ctx.lineTo(screenPoint.x, screenPoint.y);
            }

            ctx.lineTo(screen2.x, screen2.y);
            ctx.stroke();

            // Inner bright core
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.shadowBlur = 0;
        },
        update: function() {
            this.life -= 0.015; // Much slower fade (was 0.05)
        }
    });
}

// Explosion ring effect
function createExplosionEffect(x, y, radius) {
    gameState.particles.push({
        type: 'explosion',
        x, y,
        radius: 0,
        maxRadius: radius,
        life: 1,
        draw: function() {
            const screen = toScreen(this.x, this.y);

            ctx.strokeStyle = `rgba(255, 69, 0, ${this.life})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner glow
            ctx.strokeStyle = `rgba(255, 140, 0, ${this.life * 0.5})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        },
        update: function() {
            this.radius += this.maxRadius / 10;
            this.life -= 0.1;
            if (this.radius >= this.maxRadius) this.life = 0;
        }
    });
}

// Create awesome death explosion with multiple particle types
function createDeathExplosion(x, y, isBoss = false, colorPalette = null) {
    const particleCount = isBoss ? 40 : 20;
    const colors = colorPalette || ['#ff6b35', '#f7931e', '#fdc830', '#ff4444', '#ff8800'];

    // Explosive particles shooting outward
    for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 * i) / particleCount;
        const speed = isBoss ? 4 + Math.random() * 3 : 2 + Math.random() * 2;
        const color = colors[Math.floor(Math.random() * colors.length)];

        gameState.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: isBoss ? 4 + Math.random() * 3 : 2 + Math.random() * 2,
            color: color,
            alpha: 1,
            gravity: 0.1,
            friction: 0.98,
            life: 1,
            maxLife: 1,
            draw: function() {
                const screen = toScreen(this.x, this.y);
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            },
            update: function() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.life -= 0.02;
                this.alpha = this.life;
                this.size *= 0.97;
            }
        });
    }

    // Add central flash explosion ring
    const ringColor = colors[0]; // Use primary color from palette
    const glowColor = colors[2] || colors[1]; // Use lighter color for inner glow

    gameState.particles.push({
        type: 'flash',
        x: x,
        y: y,
        radius: 5,
        maxRadius: isBoss ? 60 : 30,
        life: 1,
        ringColor: ringColor,
        glowColor: glowColor,
        draw: function() {
            const screen = toScreen(this.x, this.y);

            // Outer ring
            ctx.save();
            ctx.globalAlpha = this.life * 0.8;
            ctx.strokeStyle = this.ringColor;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.ringColor;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner glow
            ctx.strokeStyle = this.glowColor;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.glowColor;
            ctx.stroke();
            ctx.restore();
        },
        update: function() {
            this.radius += (this.maxRadius - this.radius) * 0.3;
            this.life -= 0.05;
        }
    });

    // Sparks
    const sparkCount = isBoss ? 15 : 8;
    for (let i = 0; i < sparkCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 4;

        gameState.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            size: 1 + Math.random(),
            color: '#ffffff',
            alpha: 1,
            gravity: 0.15,
            life: 1,
            draw: function() {
                const screen = toScreen(this.x, this.y);
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#ffff00';
                ctx.fillRect(screen.x - this.size/2, screen.y - this.size/2, this.size, this.size);
                ctx.restore();
            },
            update: function() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.96;
                this.life -= 0.025;
                this.alpha = this.life;
            }
        });
    }
}

// Initialize
const player = new Player();

// Spawn enemies
function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    const spawnDistance = 50; // Distance outside visible screen

    switch(side) {
        case 0: // Top
            x = camera.x + Math.random() * canvas.width;
            y = camera.y - spawnDistance;
            break;
        case 1: // Right
            x = camera.x + canvas.width + spawnDistance;
            y = camera.y + Math.random() * canvas.height;
            break;
        case 2: // Bottom
            x = camera.x + Math.random() * canvas.width;
            y = camera.y + canvas.height + spawnDistance;
            break;
        case 3: // Left
            x = camera.x - spawnDistance;
            y = camera.y + Math.random() * canvas.height;
            break;
    }

    // Make sure enemies spawn within world bounds
    x = Math.max(0, Math.min(x, CONFIG.world.width));
    y = Math.max(0, Math.min(y, CONFIG.world.height));

    // Random enemy type selection with weighted probabilities
    // Enemy types unlock based on game time to progressively increase difficulty
    const gameTimeMinutes = gameState.gameTime / 60000; // Convert to minutes
    const roll = Math.random();

    // Phase 1 (0-1 min): Only normal enemies and occasional chargers
    if (gameTimeMinutes < 1) {
        if (roll < 0.2) {
            gameState.enemies.push(new ChargerEnemy(x, y));
        } else {
            gameState.enemies.push(new Enemy(x, y));
        }
    }
    // Phase 2 (1-2 min): Introduce Swarm and Teleporter
    else if (gameTimeMinutes < 2) {
        if (roll < 0.1) {
            // Swarm enemies spawn in groups of 3-5
            const swarmSize = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < swarmSize; i++) {
                const angle = (Math.PI * 2 / swarmSize) * i + Math.random() * 0.5;
                const offsetDist = 30;
                gameState.enemies.push(new SwarmEnemy(
                    x + Math.cos(angle) * offsetDist,
                    y + Math.sin(angle) * offsetDist
                ));
            }
        } else if (roll < 0.25) {
            gameState.enemies.push(new TeleporterEnemy(x, y));
        } else if (roll < 0.4) {
            gameState.enemies.push(new ChargerEnemy(x, y));
        } else {
            gameState.enemies.push(new Enemy(x, y));
        }
    }
    // Phase 3 (2-4 min): Add Splitter and Ranged
    else if (gameTimeMinutes < 4) {
        if (roll < 0.12) {
            const swarmSize = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < swarmSize; i++) {
                const angle = (Math.PI * 2 / swarmSize) * i + Math.random() * 0.5;
                const offsetDist = 30;
                gameState.enemies.push(new SwarmEnemy(
                    x + Math.cos(angle) * offsetDist,
                    y + Math.sin(angle) * offsetDist
                ));
            }
        } else if (roll < 0.22) {
            gameState.enemies.push(new TeleporterEnemy(x, y));
        } else if (roll < 0.32) {
            gameState.enemies.push(new ChargerEnemy(x, y));
        } else if (roll < 0.42) {
            gameState.enemies.push(new SplitterEnemy(x, y, 1));
        } else if (roll < 0.52) {
            gameState.enemies.push(new RangedEnemy(x, y));
        } else {
            gameState.enemies.push(new Enemy(x, y));
        }
    }
    // Phase 4 (4+ min): Full roster including Tank and Healer
    else {
        if (roll < 0.15) {
            const swarmSize = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < swarmSize; i++) {
                const angle = (Math.PI * 2 / swarmSize) * i + Math.random() * 0.5;
                const offsetDist = 30;
                gameState.enemies.push(new SwarmEnemy(
                    x + Math.cos(angle) * offsetDist,
                    y + Math.sin(angle) * offsetDist
                ));
            }
        } else if (roll < 0.25) {
            gameState.enemies.push(new TeleporterEnemy(x, y));
        } else if (roll < 0.35) {
            gameState.enemies.push(new ChargerEnemy(x, y));
        } else if (roll < 0.45) {
            gameState.enemies.push(new SplitterEnemy(x, y, 1));
        } else if (roll < 0.55) {
            gameState.enemies.push(new RangedEnemy(x, y));
        } else if (roll < 0.60) {
            gameState.enemies.push(new TankEnemy(x, y));
        } else if (roll < 0.65) {
            gameState.enemies.push(new HealerEnemy(x, y));
        } else {
            gameState.enemies.push(new Enemy(x, y));
        }
    }
}

// Auto-attack system
function autoAttack(currentTime) {
    // Use player.weapons if available, otherwise fall back to gameState.weapons
    const weapons = gameState.player.weapons || gameState.weapons || [];
    weapons.forEach(weapon => {
        // Skip arcane orbs - they are passive
        if (weapon.type === 'arcane') return;

        if (currentTime - weapon.lastFired > weapon.cooldown) {
            // Sword Spin - activate spinning attack
            if (weapon.type === 'sword_spin') {
                if (gameState.swordSpinAttack) {
                    gameState.swordSpinAttack.activate();
                    weapon.lastFired = currentTime;
                }
                return;
            }
            // Homing missiles - just spawn them, they find targets themselves
            if (weapon.type === 'homing_missile') {
                if (gameState.enemies.length > 0) {
                    gameState.homingMissiles.push(new HomingMissile(
                        gameState.player.x,
                        gameState.player.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Tornado - spawn towards nearest enemy
            if (weapon.type === 'tornado') {
                if (gameState.enemies.length > 0) {
                    // Find nearest enemy for direction
                    let nearestEnemy = gameState.enemies[0];
                    let nearestDist = Infinity;
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - gameState.player.x, 2) +
                            Math.pow(enemy.y - gameState.player.y, 2)
                        );
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });

                    gameState.tornadoes.push(new Tornado(
                        gameState.player.x,
                        gameState.player.y,
                        nearestEnemy.x,
                        nearestEnemy.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Spinning Blade - boomerang towards nearest enemy
            if (weapon.type === 'spinning_blade') {
                if (gameState.enemies.length > 0) {
                    // Find nearest enemy for direction
                    let nearestEnemy = gameState.enemies[0];
                    let nearestDist = Infinity;
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - gameState.player.x, 2) +
                            Math.pow(enemy.y - gameState.player.y, 2)
                        );
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });

                    gameState.spinningBlades.push(new SpinningBlade(
                        gameState.player.x,
                        gameState.player.y,
                        nearestEnemy.x,
                        nearestEnemy.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Meteor Strike - random meteor falls from sky
            if (weapon.type === 'meteor') {
                if (gameState.enemies.length > 0) {
                    // Target random enemy or random location near enemies
                    const randomEnemy = gameState.enemies[Math.floor(Math.random() * gameState.enemies.length)];

                    gameState.meteors.push(new Meteor(
                        randomEnemy.x,
                        randomEnemy.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Chain Lightning - jumps between enemies
            if (weapon.type === 'chain_lightning') {
                if (gameState.enemies.length > 0) {
                    gameState.chainLightnings.push(new ChainLightning(
                        gameState.player.x,
                        gameState.player.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Spirit Wolf - summon wolf companion
            if (weapon.type === 'spirit_wolf') {
                // Max 3 wolves at a time
                if (gameState.spiritWolves.length < 3) {
                    const angle = Math.random() * Math.PI * 2;
                    const spawnDist = 50;
                    gameState.spiritWolves.push(new SpiritWolf(
                        gameState.player.x + Math.cos(angle) * spawnDist,
                        gameState.player.y + Math.sin(angle) * spawnDist,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Black Hole - create gravity well
            if (weapon.type === 'black_hole') {
                if (gameState.enemies.length > 0) {
                    // Target location near enemies
                    const randomEnemy = gameState.enemies[Math.floor(Math.random() * gameState.enemies.length)];
                    gameState.blackHoles.push(new BlackHole(
                        randomEnemy.x,
                        randomEnemy.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Poison Cloud - create toxic cloud
            if (weapon.type === 'poison_cloud') {
                if (gameState.enemies.length > 0) {
                    const randomEnemy = gameState.enemies[Math.floor(Math.random() * gameState.enemies.length)];
                    gameState.poisonClouds.push(new PoisonCloud(
                        randomEnemy.x,
                        randomEnemy.y,
                        weapon
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Crystal Shard - exploding projectile
            if (weapon.type === 'crystal_shard') {
                if (gameState.enemies.length > 0) {
                    let nearestEnemy = gameState.enemies[0];
                    let nearestDist = Infinity;
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - gameState.player.x, 2) +
                            Math.pow(enemy.y - gameState.player.y, 2)
                        );
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });

                    gameState.crystalShards.push(new CrystalShard(
                        gameState.player.x,
                        gameState.player.y,
                        nearestEnemy.x,
                        nearestEnemy.y,
                        weapon,
                        false
                    ));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Frost Nova - freeze all nearby enemies
            if (weapon.type === 'frost_nova') {
                if (gameState.enemies.length > 0) {
                    gameState.frostNovas.push(new FrostNova(weapon));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Thunder Hammer - melee AOE
            if (weapon.type === 'thunder_hammer') {
                if (gameState.enemies.length > 0) {
                    gameState.thunderHammers.push(new ThunderHammer(weapon));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Shadow Clone - summon clone
            if (weapon.type === 'shadow_clone') {
                // Max 2 clones at a time
                if (gameState.shadowClones.length < 2) {
                    gameState.shadowClones.push(new ShadowClone(weapon));
                    weapon.lastFired = currentTime;
                }
                return;
            }

            // Regular projectile weapons - find nearest enemy
            let nearestEnemy = null;
            let nearestDist = weapon.range;

            gameState.enemies.forEach(enemy => {
                const dist = Math.sqrt(
                    Math.pow(enemy.x - gameState.player.x, 2) +
                    Math.pow(enemy.y - gameState.player.y, 2)
                );
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy) {
                gameState.projectiles.push(new Projectile(
                    gameState.player.x,
                    gameState.player.y,
                    nearestEnemy.x,
                    nearestEnemy.y,
                    weapon
                ));
                weapon.lastFired = currentTime;
            }
        }
    });
}

// XP System
function addXP(amount) {
    gameState.player.xp += amount;
    if (gameState.player.xp >= gameState.player.xpToLevel) {
        levelUp();
    }
}

function levelUp() {
    gameState.player.level++;
    gameState.player.xp = 0;
    gameState.player.xpToLevel = Math.floor(gameState.player.xpToLevel * 1.5);
    gameState.isPaused = true;

    // Check which weapons player already has
    const hasWeapon = (type) => gameState.player.weapons.some(w => w.type === type);
    const getWeapon = (type) => gameState.player.weapons.find(w => w.type === type);
    const canAddWeapon = () => gameState.player.weapons.length < gameState.player.maxWeapons;

    // Generate 3 random upgrades for React UI
    const allUpgrades = [
        { name: 'Max HP +20', desc: 'Increase maximum health', type: 'stat', apply: () => { gameState.player.maxHp += 20; gameState.player.hp += 20; } },
        { name: 'Speed +0.5', desc: 'Move faster', type: 'stat', apply: () => { gameState.player.speed += 0.5; } },
        { name: 'All Weapons Damage +5', desc: 'More damage with all weapons', type: 'stat', apply: () => { gameState.player.weapons.forEach(w => w.damage += 5); } },
        { name: 'All Weapons Speed +10%', desc: 'Attack faster with all weapons', type: 'stat', apply: () => { gameState.player.weapons.forEach(w => w.cooldown *= 0.9); } },
        { name: 'All Weapons Range +30', desc: 'Longer attack range', type: 'stat', apply: () => { gameState.player.weapons.forEach(w => w.range += 30); } },
        { name: 'Heal 50 HP', desc: 'Restore health', type: 'stat', apply: () => { gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 50); } }
    ];

    // Add XP Magnet upgrade if player doesn't have it yet
    if (!gameState.player.hasXPMagnet) {
        allUpgrades.push({
            name: 'XP Magnet',
            desc: 'Attract XP orbs automatically',
            type: 'stat',
            apply: () => { gameState.player.hasXPMagnet = true; }
        });
    }

    // Add weapon-specific upgrades for existing weapons
    gameState.player.weapons.forEach(weapon => {
        // Level up existing weapon
        allUpgrades.push({
            name: `${weapon.name} Level ${weapon.level + 1}`,
            desc: `+3 damage, -5% cooldown`,
            type: 'weapon_upgrade',
            weaponType: weapon.type,
            apply: () => {
                weapon.level++;
                weapon.damage += 3;
                weapon.cooldown *= 0.95;
            }
        });

        // Add projectile count upgrade for certain weapons
        if (['magic_missile', 'fireball', 'ice', 'homing_missile'].includes(weapon.type)) {
            if (!weapon.projectileCount) weapon.projectileCount = 1;
            if (weapon.projectileCount < 5) { // Max 5 projectiles
                allUpgrades.push({
                    name: `${weapon.name} +1 Projectile`,
                    desc: `${weapon.projectileCount + 1} ${weapon.name}s at once`,
                    type: 'weapon_upgrade',
                    weaponType: weapon.type,
                    apply: () => {
                        weapon.projectileCount++;
                    }
                });
            }
        }

        // Weapon-specific upgrades
        if (weapon.type === 'arcane' && gameState.orbitingOrbs.length < 8) {
            allUpgrades.push({
                name: 'Arcane Orb +1 Orb',
                desc: `Add 1 orb (now ${gameState.orbitingOrbs.length})`,
                type: 'weapon_upgrade',
                weaponType: weapon.type,
                apply: () => {
                    const currentCount = gameState.orbitingOrbs.length;
                    gameState.orbitingOrbs.push(new OrbitingOrb(currentCount, currentCount + 1, weapon));
                }
            });
        }

        if (weapon.type === 'fireball' && weapon.explosionRadius) {
            allUpgrades.push({
                name: 'Fireball +20 Explosion Radius',
                desc: `Bigger explosions (${weapon.explosionRadius}px)`,
                type: 'weapon_upgrade',
                weaponType: weapon.type,
                apply: () => {
                    weapon.explosionRadius += 20;
                }
            });
        }
    });

    // New weapon upgrades (only show if player can add more weapons AND doesn't have them yet)
    if (canAddWeapon() && !hasWeapon('lightning')) {
        allUpgrades.push({
            name: 'âš¡ Lightning Bolt',
            desc: 'Chain lightning jumps between foes',
            type: 'new_weapon',
            weaponType: 'lightning',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'lightning',
                    name: 'Lightning Bolt',
                    damage: 15,
                    range: 250,
                    cooldown: 1000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('fireball')) {
        allUpgrades.push({
            name: 'ðŸ”¥ Fireball',
            desc: 'Explosive fireballs hit multiple foes',
            type: 'new_weapon',
            weaponType: 'fireball',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'fireball',
                    name: 'Fireball',
                    damage: 25,
                    range: 200,
                    cooldown: 1500,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0,
                    explosionRadius: 50
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('ice')) {
        allUpgrades.push({
            name: 'Ice Spikes',
            desc: 'Freezing spikes slow enemies',
            type: 'new_weapon',
            weaponType: 'ice',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'ice',
                    name: 'Ice Spikes',
                    damage: 12,
                    range: 180,
                    cooldown: 800,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('arcane')) {
        allUpgrades.push({
            name: 'ðŸŒ€ Arcane Orb',
            desc: 'Three orbiting orbs protect and damage',
            type: 'new_weapon',
            weaponType: 'arcane',
            apply: () => {
                const weapon = {
                    type: 'arcane',
                    name: 'Arcane Orb',
                    damage: 8,
                    range: 100,
                    cooldown: 100,
                    level: 1,
                    projectileCount: 3,
                    lastFired: 0
                };
                gameState.player.weapons.push(weapon);

                // Create 3 orbiting orbs
                for (let i = 0; i < 3; i++) {
                    gameState.orbitingOrbs.push(new OrbitingOrb(i, 3, weapon));
                }
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('homing_missile')) {
        allUpgrades.push({
            name: 'ðŸš€ Homing Missiles',
            desc: 'Missiles track and chase enemies',
            type: 'new_weapon',
            weaponType: 'homing_missile',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'homing_missile',
                    name: 'Homing Missiles',
                    damage: 15,
                    range: 0, // Not used for missiles
                    cooldown: 800, // Fire every 0.8 seconds
                    level: 1,
                    lastFired: 0
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('chain_lightning')) {
        allUpgrades.push({
            name: 'âš¡ Chain Lightning',
            desc: 'Lightning jumps between 5 enemies',
            type: 'new_weapon',
            weaponType: 'chain_lightning',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'chain_lightning',
                    name: 'Chain Lightning',
                    damage: 20,
                    range: 200,
                    cooldown: 2000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('spirit_wolf')) {
        allUpgrades.push({
            name: 'ðŸº Spirit Wolf',
            desc: 'Summon ghost wolves (max 3)',
            type: 'new_weapon',
            weaponType: 'spirit_wolf',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'spirit_wolf',
                    name: 'Spirit Wolf',
                    damage: 18,
                    range: 0,
                    cooldown: 5000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('black_hole')) {
        allUpgrades.push({
            name: 'Black Hole',
            desc: 'Gravity well pulls and damages enemies',
            type: 'new_weapon',
            weaponType: 'black_hole',
            apply: () => {
                gameState.player.weapons.push({
                    type: 'black_hole',
                    name: 'Black Hole',
                    damage: 100,
                    range: 250,
                    cooldown: 8000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                });
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('poison_cloud')) {
        allUpgrades.push({
            name: 'â˜ ï¸ Poison Cloud',
            desc: 'Toxic clouds damage over time',
            type: 'new_weapon',
            weaponType: 'poison_cloud',
            apply: () => {
                const weapon = {
                    type: 'poison_cloud',
                    name: 'Poison Cloud',
                    damage: 30,
                    range: 250,
                    cooldown: 3000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                };
                weapon.lastFired = Date.now() - weapon.cooldown; // Start ready
                gameState.player.weapons.push(weapon);
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('crystal_shard')) {
        allUpgrades.push({
            name: 'ðŸ’Ž Crystal Shard',
            desc: 'Crystals split into fragments',
            type: 'new_weapon',
            weaponType: 'crystal_shard',
            apply: () => {
                const weapon = {
                    type: 'crystal_shard',
                    name: 'Crystal Shard',
                    damage: 20,
                    range: 300,
                    cooldown: 1500,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                };
                weapon.lastFired = Date.now() - weapon.cooldown; // Start ready
                gameState.player.weapons.push(weapon);
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('frost_nova')) {
        allUpgrades.push({
            name: 'â„ï¸ Frost Nova',
            desc: 'Freezes all nearby enemies',
            type: 'new_weapon',
            weaponType: 'frost_nova',
            apply: () => {
                const weapon = {
                    type: 'frost_nova',
                    name: 'Frost Nova',
                    damage: 40,
                    range: 200,
                    cooldown: 4000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                };
                weapon.lastFired = Date.now() - weapon.cooldown; // Start ready
                gameState.player.weapons.push(weapon);
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('thunder_hammer')) {
        allUpgrades.push({
            name: 'âš¡ Thunder Hammer',
            desc: 'Melee AOE attack stuns enemies',
            type: 'new_weapon',
            weaponType: 'thunder_hammer',
            apply: () => {
                const weapon = {
                    type: 'thunder_hammer',
                    name: 'Thunder Hammer',
                    damage: 50,
                    range: 120,
                    cooldown: 3500,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                };
                weapon.lastFired = Date.now() - weapon.cooldown; // Start ready
                gameState.player.weapons.push(weapon);
            }
        });
    }

    if (canAddWeapon() && !hasWeapon('shadow_clone')) {
        allUpgrades.push({
            name: 'ðŸ‘¤ Shadow Clone',
            desc: 'Summon clones that mimic attacks',
            type: 'new_weapon',
            weaponType: 'shadow_clone',
            apply: () => {
                const weapon = {
                    type: 'shadow_clone',
                    name: 'Shadow Clone',
                    damage: 15,
                    range: 0,
                    cooldown: 15000,
                    level: 1,
                    projectileCount: 1,
                    lastFired: 0
                };
                weapon.lastFired = Date.now() - weapon.cooldown; // Start ready
                gameState.player.weapons.push(weapon);
            }
        });
    }

    // Select 3 unique upgrades and assign rarities
    const selectedUpgrades = [];
    while (selectedUpgrades.length < 3 && allUpgrades.length > 0) {
        const upgrade = allUpgrades[Math.floor(Math.random() * allUpgrades.length)];
        if (!selectedUpgrades.includes(upgrade)) {
            // Assign random rarity to this upgrade
            const rarity = getRandomRarity();
            upgrade.rarity = rarity;

            // Apply rarity multiplier to stat bonuses
            if (upgrade.type === 'stat' && !upgrade.name.includes('Heal')) {
                // Create a new apply function that uses rarity multiplier
                const originalApply = upgrade.apply;
                const multiplier = rarity.statMultiplier;

                // Update description to show boosted value
                if (upgrade.name.includes('Max HP')) {
                    const baseValue = 20;
                    const boostedValue = Math.floor(baseValue * multiplier);
                    upgrade.name = `Max HP +${boostedValue}`;
                    upgrade.apply = () => {
                        gameState.player.maxHp += boostedValue;
                        gameState.player.hp += boostedValue;
                    };
                } else if (upgrade.name.includes('Speed')) {
                    const baseValue = 0.5;
                    const boostedValue = +(baseValue * multiplier).toFixed(1);
                    upgrade.name = `Speed +${boostedValue}`;
                    upgrade.apply = () => {
                        gameState.player.speed += boostedValue;
                    };
                } else if (upgrade.name.includes('All Weapons Damage')) {
                    const baseValue = 5;
                    const boostedValue = Math.floor(baseValue * multiplier);
                    upgrade.name = `All Weapons Damage +${boostedValue}`;
                    upgrade.apply = () => {
                        gameState.player.weapons.forEach(w => w.damage += boostedValue);
                    };
                } else if (upgrade.name.includes('All Weapons Range')) {
                    const baseValue = 30;
                    const boostedValue = Math.floor(baseValue * multiplier);
                    upgrade.name = `All Weapons Range +${boostedValue}`;
                    upgrade.apply = () => {
                        gameState.player.weapons.forEach(w => w.range += boostedValue);
                    };
                } else if (upgrade.name.includes('weapon_upgrade') || upgrade.name.includes('Level')) {
                    // Weapon upgrade bonuses scale with rarity
                    const baseDamage = 3;
                    const boostedDamage = Math.floor(baseDamage * multiplier);
                    if (upgrade.weaponType) {
                        const weaponName = upgrade.name.split(' Level')[0];
                        upgrade.name = `${weaponName} Level ${getWeapon(upgrade.weaponType).level + 1}`;
                        upgrade.desc = `Upgrade: +${boostedDamage} damage, -5% cooldown`;
                        upgrade.apply = () => {
                            const weapon = getWeapon(upgrade.weaponType);
                            weapon.level++;
                            weapon.damage += boostedDamage;
                            weapon.cooldown *= 0.95;
                        };
                    }
                }
            }

            selectedUpgrades.push(upgrade);
        }
    }

    // Expose upgrades to React UI
    gameState.currentUpgrades = selectedUpgrades;
    gameState.showLevelUp = true;
}

// Function called when player selects an upgrade
window.selectUpgrade = function(index) {
    if (gameState.currentUpgrades && gameState.currentUpgrades[index]) {
        gameState.currentUpgrades[index].apply();
        gameState.showLevelUp = false;
        gameState.currentUpgrades = null;
        gameState.isPaused = false;
    }
};

// Game Over
function gameOver() {
    gameState.isGameOver = true;
    document.getElementById('finalTime').textContent = document.getElementById('time').textContent;
    document.getElementById('finalKills').textContent = gameState.kills;
    document.getElementById('gameOverScreen').classList.remove('hidden');
}

// UI is now handled by React - no need for updateUI function anymore

// Draw background/map
function drawBackground() {
    // If background texture is loaded, use it; otherwise fall back to grid
    if (backgroundTexture.complete && backgroundTexture.naturalWidth > 0) {
        const tileSize = backgroundTexture.width; // Use actual image size

        // Calculate visible tiles
        const startX = Math.floor(camera.x / tileSize) * tileSize;
        const startY = Math.floor(camera.y / tileSize) * tileSize;
        const endX = camera.x + canvas.width + tileSize;
        const endY = camera.y + canvas.height + tileSize;

        // Enable pixelated rendering for crisp pixel art
        ctx.imageSmoothingEnabled = false;

        // Draw tiled background texture
        for (let x = startX; x < endX; x += tileSize) {
            for (let y = startY; y < endY; y += tileSize) {
                const screenX = x - camera.x;
                const screenY = y - camera.y;
                ctx.drawImage(backgroundTexture, screenX, screenY, tileSize, tileSize);
            }
        }
    } else {
        // Fallback: Original grid pattern
        const tileSize = 64;
        const startX = Math.floor(camera.x / tileSize) * tileSize;
        const startY = Math.floor(camera.y / tileSize) * tileSize;
        const endX = camera.x + canvas.width + tileSize;
        const endY = camera.y + canvas.height + tileSize;

        for (let x = startX; x < endX; x += tileSize) {
            for (let y = startY; y < endY; y += tileSize) {
                const screenX = x - camera.x;
                const screenY = y - camera.y;
                const isDark = (Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2;
                ctx.fillStyle = isDark ? '#1a2332' : '#2a3142';
                ctx.fillRect(screenX, screenY, tileSize, tileSize);
                ctx.strokeStyle = 'rgba(100, 100, 150, 0.1)';
                ctx.lineWidth = 1;
                ctx.strokeRect(screenX, screenY, tileSize, tileSize);
            }
        }
    }

    // Draw world boundaries
    ctx.strokeStyle = '#e94560';
    ctx.lineWidth = 4;
    ctx.strokeRect(-camera.x, -camera.y, CONFIG.world.width, CONFIG.world.height);
}

// Update camera to follow player smoothly
function updateCamera() {
    // Calculate target position
    let targetX = gameState.player.x - canvas.width / 2;
    let targetY = gameState.player.y - canvas.height / 2;

    // Clamp target within world bounds BEFORE smoothing to avoid jitter
    targetX = Math.max(0, Math.min(targetX, CONFIG.world.width - canvas.width));
    targetY = Math.max(0, Math.min(targetY, CONFIG.world.height - canvas.height));

    // Smooth camera movement towards clamped target
    camera.x += (targetX - camera.x) * camera.smoothing;
    camera.y += (targetY - camera.y) * camera.smoothing;

    // Final clamp to ensure we stay in bounds (shouldn't be needed, but safety)
    camera.x = Math.max(0, Math.min(camera.x, CONFIG.world.width - canvas.width));
    camera.y = Math.max(0, Math.min(camera.y, CONFIG.world.height - canvas.height));
}

// Game Loop
let lastTime = 0;
let frameCount = 0;
function gameLoop(currentTime) {
    frameCount++;
    if (frameCount === 1) {
        console.log('First game loop frame running!');
        console.log('Current time:', currentTime);
        // Initialize timing on first frame to prevent huge deltaTime
        lastTime = currentTime;
        gameState.lastSpawn = currentTime;
        gameState.lastAttack = currentTime;
    }

    // Safety check - stop if canvas or context is gone
    if (!canvas || !ctx) {
        console.error('Canvas lost! Stopping game loop.');
        return;
    }

    // Calculate deltaTime, but cap it to prevent huge jumps
    const deltaTime = lastTime ? Math.min(currentTime - lastTime, 100) : 16.67;
    lastTime = currentTime;

    // Store currentTime in gameState for UI to use
    gameState.currentTime = currentTime;

    // Debug: Log if we get a big deltaTime spike
    if (deltaTime > 50) {
        console.warn(`WARNING: Large deltaTime detected: ${deltaTime.toFixed(2)}ms at ${(gameState.gameTime / 1000).toFixed(1)}s - Frame ${frameCount}`);
        console.trace('Stack trace for large deltaTime');
    }

    // Debug: Log camera position changes
    const oldCameraX = camera.x;
    const oldCameraY = camera.y;

    // Log every 60 frames (about once per second)
    if (frameCount % 60 === 0) {
        console.log(`Frame ${frameCount}: Time: ${(gameState.gameTime / 1000).toFixed(1)}s, Enemies: ${gameState.enemies.length}, Player HP: ${gameState.player.hp}, FPS: ~${Math.round(1000/deltaTime)}`);
    }

    // Always update camera and draw, even when paused
    updateCamera();

    // Debug: Log large camera jumps
    const cameraDeltaX = Math.abs(camera.x - oldCameraX);
    const cameraDeltaY = Math.abs(camera.y - oldCameraY);
    if (cameraDeltaX > 50 || cameraDeltaY > 50) {
        console.warn(`WARNING: Large camera jump detected: Î”X=${cameraDeltaX.toFixed(1)}, Î”Y=${cameraDeltaY.toFixed(1)} at ${(gameState.gameTime / 1000).toFixed(1)}s`);
        console.log(`Player pos: (${gameState.player.x.toFixed(1)}, ${gameState.player.y.toFixed(1)}), Camera: (${camera.x.toFixed(1)}, ${camera.y.toFixed(1)})`);
    }

    if (!gameState.isPaused && !gameState.isGameOver) {
        // Only update gameTime when not paused
        gameState.gameTime += deltaTime;

        // Update ultimate cooldown
        if (gameState.player.ultimateCooldown > 0) {
            gameState.player.ultimateCooldown -= deltaTime;
            if (gameState.player.ultimateCooldown < 0) {
                gameState.player.ultimateCooldown = 0;
            }
        }

        // Check achievements every second
        if (!gameState.lastAchievementCheck || gameState.gameTime - gameState.lastAchievementCheck > 1000) {
            checkAchievements();
            gameState.lastAchievementCheck = gameState.gameTime;
        }

        // Handle Meteor Storm ultimate
        if (gameState.meteorStormStartTime) {
            const elapsed = Date.now() - gameState.meteorStormStartTime;

            if (elapsed > 8000) {
                // Storm finished
                gameState.meteorStormStartTime = null;
                gameState.meteorStormLastSpawn = null;
                gameState.player.ultimateActive = false;
                console.log('Meteor Storm ended');
            } else {
                // Spawn meteors every 400ms
                if (Date.now() - gameState.meteorStormLastSpawn > 400) {
                    console.log('Spawning meteors!');
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 200 + Math.random() * 400;
                        gameState.meteors.push({
                            x: gameState.player.x + Math.cos(angle) * distance,
                            y: gameState.player.y + Math.sin(angle) * distance - 500, // Start above
                            targetX: gameState.player.x + Math.cos(angle) * distance,
                            targetY: gameState.player.y + Math.sin(angle) * distance,
                            speed: 15,
                            damage: 150,
                            radius: 80,
                            size: 12,
                            trail: []
                        });
                    }
                    gameState.meteorStormLastSpawn = Date.now();
                }
            }
        }
    } else {
        // When paused, we need to update timers to prevent spawns immediately after unpause
        gameState.lastSpawn = currentTime;
        gameState.lastAttack = currentTime;
    }

    // Always draw the game
    if (true) { // Changed from if (!gameState.isPaused) to always draw

        // Apply screen shake effect
        ctx.save();
        if (gameState.screenShake) {
            const elapsed = currentTime - gameState.screenShake.startTime;
            if (elapsed < gameState.screenShake.duration) {
                // Shake decreases over time
                const shakeProgress = 1 - (elapsed / gameState.screenShake.duration);
                const shakeX = (Math.random() - 0.5) * gameState.screenShake.intensity * shakeProgress;
                const shakeY = (Math.random() - 0.5) * gameState.screenShake.intensity * shakeProgress;
                ctx.translate(shakeX, shakeY);
            } else {
                gameState.screenShake = null;
            }
        }

        // Clear canvas
        ctx.fillStyle = '#0f1419';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw background
        drawBackground();

        // Update and draw player
        if (player) {
            if (!gameState.isPaused && !gameState.isGameOver) {
                player.update(); // Only update when not paused
            }
            player.draw(); // Always draw
        } else {
            console.warn('Player not initialized!');
        }

        // Spawn enemies (only when not paused) - with dynamic difficulty
        const difficulty = getDifficultyMultipliers();
        if (!gameState.isPaused && !gameState.isGameOver && currentTime - gameState.lastSpawn > difficulty.spawnRate) {
            if (gameState.enemies.length < difficulty.maxEnemies) {
                spawnEnemy();
                // Debug: Log first few spawns and difficulty changes
                if (gameState.enemies.length <= 5) {
                    console.log(`ðŸ§Ÿ Spawned enemy #${gameState.enemies.length} at ${(gameState.gameTime / 1000).toFixed(1)}s`);
                }

                // Log difficulty scaling every 60 seconds (1 minute)
                if (!gameState.lastDifficultyLog || gameState.gameTime - gameState.lastDifficultyLog > 60000) {
                    gameState.lastDifficultyLog = gameState.gameTime;
                    const minutes = Math.floor(gameState.gameTime / 60000);
                    console.log(`DIFFICULTY TIER ${difficulty.intervals} (${minutes} min): Speed x${difficulty.speed.toFixed(2)}, HP x${difficulty.hp.toFixed(2)}, Damage x${difficulty.damage.toFixed(2)}, Spawn: ${difficulty.spawnRate.toFixed(0)}ms, Max: ${difficulty.maxEnemies}`);
                }
            }
            gameState.lastSpawn = currentTime;
        }

        // Spawn Necromancer Boss every 60 seconds (only when not paused)
        if (!gameState.isPaused && !gameState.isGameOver) {
            // Initialize boss spawn tracker if not exists
            if (!gameState.lastBossSpawn) {
                gameState.lastBossSpawn = 0;
            }
            if (!gameState.lastMajorBossSpawn) {
                gameState.lastMajorBossSpawn = 0;
            }

            const timeSinceLastBoss = gameState.gameTime - gameState.lastBossSpawn;
            const bossSpawnInterval = 60000; // 60 seconds

            // Check if there's already a boss alive
            const hasBoss = gameState.enemies.some(e => e.isBoss && !e.isMajorBoss);
            const hasMajorBoss = gameState.enemies.some(e => e.isMajorBoss);

            // Spawn regular Necromancer boss
            if (timeSinceLastBoss > bossSpawnInterval && !hasBoss && gameState.gameTime > 30000) {
                // Spawn boss at a distance from player
                const angle = Math.random() * Math.PI * 2;
                const distance = 400; // Spawn far from player
                const bossX = gameState.player.x + Math.cos(angle) * distance;
                const bossY = gameState.player.y + Math.sin(angle) * distance;

                // Clamp to world bounds
                const clampedX = Math.max(50, Math.min(CONFIG.world.width - 50, bossX));
                const clampedY = Math.max(50, Math.min(CONFIG.world.height - 50, bossY));

                gameState.enemies.push(new NecromancerBoss(clampedX, clampedY));
                gameState.lastBossSpawn = gameState.gameTime;

                console.log(`ðŸ‘¹ NECROMANCER BOSS SPAWNED at ${(gameState.gameTime / 1000).toFixed(1)}s!`);

                // Create dramatic spawn particles
                for (let i = 0; i < 30; i++) {
                    const pAngle = Math.random() * Math.PI * 2;
                    const pSpeed = 2 + Math.random() * 3;
                    gameState.particles.push({
                        x: clampedX,
                        y: clampedY,
                        vx: Math.cos(pAngle) * pSpeed,
                        vy: Math.sin(pAngle) * pSpeed,
                        size: 5 + Math.random() * 5,
                        color: '#9400d3',
                        alpha: 1,
                        decay: 0.02,
                        lifetime: 50
                    });
                }
            }

            // Spawn Arch-Demon Boss every 3 minutes after 2 minutes of gameplay
            const timeSinceLastMajorBoss = gameState.gameTime - gameState.lastMajorBossSpawn;
            const majorBossSpawnInterval = 180000; // 3 minutes

            if (timeSinceLastMajorBoss > majorBossSpawnInterval && !hasMajorBoss && gameState.gameTime > 120000) {
                // Spawn major boss far from player
                const angle = Math.random() * Math.PI * 2;
                const distance = 500; // Spawn very far from player
                const bossX = gameState.player.x + Math.cos(angle) * distance;
                const bossY = gameState.player.y + Math.sin(angle) * distance;

                // Clamp to world bounds
                const clampedX = Math.max(80, Math.min(CONFIG.world.width - 80, bossX));
                const clampedY = Math.max(80, Math.min(CONFIG.world.height - 80, bossY));

                gameState.enemies.push(new ArchDemonBoss(clampedX, clampedY));
                gameState.lastMajorBossSpawn = gameState.gameTime;

                console.log(`ðŸ”¥ðŸ’€ ARCH-DEMON BOSS SPAWNED at ${(gameState.gameTime / 1000).toFixed(1)}s!`);

                // Create MASSIVE spawn effect
                for (let i = 0; i < 80; i++) {
                    const pAngle = Math.random() * Math.PI * 2;
                    const pSpeed = 3 + Math.random() * 5;
                    gameState.particles.push({
                        x: clampedX,
                        y: clampedY,
                        vx: Math.cos(pAngle) * pSpeed,
                        vy: Math.sin(pAngle) * pSpeed,
                        size: 10 + Math.random() * 15,
                        color: Math.random() < 0.5 ? '#ff0000' : '#ff6600',
                        alpha: 1,
                        decay: 0.015,
                        lifetime: 100
                    });
                }

                // Create expanding shockwave rings
                for (let ring = 0; ring < 5; ring++) {
                    setTimeout(() => {
                        for (let i = 0; i < 30; i++) {
                            const pAngle = (Math.PI * 2 / 30) * i;
                            const ringRadius = 50 + ring * 30;
                            gameState.particles.push({
                                x: clampedX + Math.cos(pAngle) * ringRadius,
                                y: clampedY + Math.sin(pAngle) * ringRadius,
                                vx: Math.cos(pAngle) * 2,
                                vy: Math.sin(pAngle) * 2,
                                size: 8,
                                color: '#ff0000',
                                alpha: 1,
                                decay: 0.03,
                                lifetime: 60
                            });
                        }
                    }, ring * 100);
                }
            }
        }

        // Update and draw enemies
        gameState.enemies.forEach(enemy => {
            if (!gameState.isPaused && !gameState.isGameOver) {
                enemy.update(); // Only update when not paused
            }
            enemy.draw(); // Always draw
        });

        // Update meteors (from ultimate)
        if (!gameState.isPaused && !gameState.isGameOver) {
            for (let i = gameState.meteors.length - 1; i >= 0; i--) {
                const meteor = gameState.meteors[i];

                // Skip meteors with update methods (boss meteors)
                if (meteor.update) continue;

                // Update ultimate meteors
                meteor.y += meteor.speed;
                meteor.speed += 0.2; // Accelerate

                // Check if hit ground
                if (meteor.y >= meteor.targetY) {
                    // Explosion damage radius
                    const explosionRadius = meteor.radius || 80;

                    // Damage enemies in explosion radius
                    let hitAnyEnemy = false;
                    gameState.enemies.forEach(enemy => {
                        const enemyDist = Math.sqrt(
                            Math.pow(enemy.x - meteor.x, 2) +
                            Math.pow(enemy.y - meteor.y, 2)
                        );

                        if (enemyDist < explosionRadius) {
                            const damage = (meteor.damage || 150) * (1 - enemyDist / explosionRadius);
                            enemy.hp -= damage;
                            hitAnyEnemy = true;
                        }
                    });

                    // Play explosion sound if hit enemies
                    if (hitAnyEnemy) {
                        SoundSystem.playHit('explosion');
                    }

                    // Create explosion particles
                    for (let j = 0; j < 20; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 2 + Math.random() * 3;
                        gameState.particles.push({
                            x: meteor.x,
                            y: meteor.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: 8 + Math.random() * 8,
                            alpha: 1,
                            color: '#8b5cf6',
                            lifetime: 40
                        });
                    }

                    gameState.meteors.splice(i, 1);
                }
            }
        }

        // Auto-attack (only when not paused)
        if (!gameState.isPaused && !gameState.isGameOver) {
            autoAttack(currentTime);
        }

        // Update and draw projectiles
        for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
            const projectile = gameState.projectiles[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (projectile.update()) {
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
            }
            projectile.draw();
        }

        // Update and draw orbiting orbs
        gameState.orbitingOrbs.forEach(orb => {
            if (!gameState.isPaused && !gameState.isGameOver) {
                orb.update(currentTime);
            }
            orb.draw();
        });

        // Update and draw tornadoes
        for (let i = gameState.tornadoes.length - 1; i >= 0; i--) {
            const tornado = gameState.tornadoes[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (tornado.update()) {
                    gameState.tornadoes.splice(i, 1);
                    continue;
                }
            }
            tornado.draw();
        }

        // Update and draw spinning blades
        for (let i = gameState.spinningBlades.length - 1; i >= 0; i--) {
            const blade = gameState.spinningBlades[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (blade.update()) {
                    gameState.spinningBlades.splice(i, 1);
                    continue;
                }
            }
            blade.draw();
        }

        // Update and draw meteors
        for (let i = gameState.meteors.length - 1; i >= 0; i--) {
            const meteor = gameState.meteors[i];

            // Handle meteors with methods (boss meteors)
            if (meteor.update && meteor.draw) {
                if (!gameState.isPaused && !gameState.isGameOver) {
                    if (meteor.update()) {
                        gameState.meteors.splice(i, 1);
                        continue;
                    }
                }
                meteor.draw();
            } else {
                // Handle simple meteors (ultimate meteors) - already updated in boss update
                // Just draw them
                const targetScreen = toScreen(meteor.x, meteor.targetY);
                ctx.fillStyle = 'rgba(139, 92, 246, 0.3)'; // Purple for ultimate
                ctx.beginPath();
                ctx.arc(targetScreen.x, targetScreen.y, meteor.radius || 60, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(targetScreen.x, targetScreen.y, meteor.radius || 60, 0, Math.PI * 2);
                ctx.stroke();

                // Meteor itself
                const meteorScreen = toScreen(meteor.x, meteor.y);
                ctx.fillStyle = '#c084fc';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#8b5cf6';
                ctx.beginPath();
                ctx.arc(meteorScreen.x, meteorScreen.y, meteor.size || 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Update and draw chain lightnings
        for (let i = gameState.chainLightnings.length - 1; i >= 0; i--) {
            const lightning = gameState.chainLightnings[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (lightning.update()) {
                    gameState.chainLightnings.splice(i, 1);
                    continue;
                }
            }
            lightning.draw();
        }

        // Update and draw spirit wolves
        for (let i = gameState.spiritWolves.length - 1; i >= 0; i--) {
            const wolf = gameState.spiritWolves[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (wolf.update()) {
                    gameState.spiritWolves.splice(i, 1);
                    continue;
                }
            }
            wolf.draw();
        }

        // Update and draw black holes
        for (let i = gameState.blackHoles.length - 1; i >= 0; i--) {
            const blackHole = gameState.blackHoles[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (blackHole.update()) {
                    gameState.blackHoles.splice(i, 1);
                    continue;
                }
            }
            blackHole.draw();
        }

        // Update and draw sword spin attack
        if (gameState.swordSpinAttack) {
            if (!gameState.isPaused && !gameState.isGameOver) {
                gameState.swordSpinAttack.update();
            }
            gameState.swordSpinAttack.draw();
        }

        // Update and draw homing missiles
        for (let i = gameState.homingMissiles.length - 1; i >= 0; i--) {
            const missile = gameState.homingMissiles[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (missile.update()) {
                    gameState.homingMissiles.splice(i, 1);
                    continue;
                }
            }
            missile.draw();
        }

        // Update and draw poison clouds
        for (let i = gameState.poisonClouds.length - 1; i >= 0; i--) {
            const cloud = gameState.poisonClouds[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (cloud.update()) {
                    gameState.poisonClouds.splice(i, 1);
                    continue;
                }
            }
            cloud.draw();
        }

        // Update and draw crystal shards
        for (let i = gameState.crystalShards.length - 1; i >= 0; i--) {
            const shard = gameState.crystalShards[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (shard.update()) {
                    gameState.crystalShards.splice(i, 1);
                    continue;
                }
            }
            shard.draw();
        }

        // Update and draw frost novas
        for (let i = gameState.frostNovas.length - 1; i >= 0; i--) {
            const nova = gameState.frostNovas[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (nova.update()) {
                    gameState.frostNovas.splice(i, 1);
                    continue;
                }
            }
            nova.draw();
        }

        // Update and draw thunder hammers
        for (let i = gameState.thunderHammers.length - 1; i >= 0; i--) {
            const hammer = gameState.thunderHammers[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (hammer.update()) {
                    gameState.thunderHammers.splice(i, 1);
                    continue;
                }
            }
            hammer.draw();
        }

        // Update and draw shadow clones
        for (let i = gameState.shadowClones.length - 1; i >= 0; i--) {
            const clone = gameState.shadowClones[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (clone.update()) {
                    gameState.shadowClones.splice(i, 1);
                    continue;
                }
            }
            clone.draw();
        }

        // Update enemy frozen/stunned states
        if (!gameState.isPaused && !gameState.isGameOver) {
            const currentTime = Date.now();
            gameState.enemies.forEach(enemy => {
                // Restore speed from frozen state
                if (enemy.frozenUntil && currentTime > enemy.frozenUntil) {
                    if (enemy.originalSpeed !== undefined) {
                        enemy.speed = enemy.originalSpeed;
                        delete enemy.originalSpeed;
                        delete enemy.frozenUntil;
                    }
                }
                // Restore speed from stunned state
                if (enemy.stunnedUntil && currentTime > enemy.stunnedUntil) {
                    if (enemy.originalSpeed !== undefined) {
                        enemy.speed = enemy.originalSpeed;
                        delete enemy.originalSpeed;
                        delete enemy.stunnedUntil;
                    }
                }
            });
        }

        // Update and draw particles
        for (let i = gameState.particles.length - 1; i >= 0; i--) {
            const particle = gameState.particles[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                // Handle both Particle objects and plain particle objects
                if (particle.update) {
                    particle.update();
                    if (particle.life <= 0) {
                        gameState.particles.splice(i, 1);
                        continue;
                    }
                } else if (particle.lifetime !== undefined) {
                    // Plain object particle (dash trail, blood particles, etc)
                    particle.x += particle.vx;
                    particle.y += particle.vy;

                    // Apply gravity if particle has it (blood particles)
                    if (particle.gravity) {
                        particle.vy += particle.gravity;
                    }

                    particle.alpha -= particle.decay;
                    particle.lifetime--;

                    if (particle.lifetime <= 0 || particle.alpha <= 0) {
                        gameState.particles.splice(i, 1);
                        continue;
                    }
                }
            }

            // Draw particle
            if (particle.draw) {
                particle.draw();
            } else if (particle.lifetime !== undefined) {
                // Draw plain object particle
                const screen = toScreen(particle.x, particle.y);
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.alpha;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Update and draw enemy projectiles
        for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
            const proj = gameState.enemyProjectiles[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                proj.x += proj.vx;
                proj.y += proj.vy;

                // Check world bounds
                if (proj.x < 0 || proj.x > CONFIG.world.width || proj.y < 0 || proj.y > CONFIG.world.height) {
                    gameState.enemyProjectiles.splice(i, 1);
                    continue;
                }

                // Check collision with player
                const dx = gameState.player.x - proj.x;
                const dy = gameState.player.y - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < CONFIG.player.size + proj.size) {
                    player.takeDamage(proj.damage);
                    gameState.enemyProjectiles.splice(i, 1);
                    continue;
                }
            }

            // Draw projectile
            const screen = toScreen(proj.x, proj.y);
            ctx.fillStyle = proj.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = proj.color;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, proj.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // Update and draw damage numbers
        for (let i = gameState.damageNumbers.length - 1; i >= 0; i--) {
            const damageNum = gameState.damageNumbers[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (damageNum.update()) {
                    gameState.damageNumbers.splice(i, 1);
                    continue;
                }
            }
            damageNum.draw();
        }

        // Update and draw XP orbs
        for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
            const orb = gameState.xpOrbs[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                if (orb.update()) {
                    // Player collected the orb
                    addXP(orb.xpValue);
                    gameState.xpOrbs.splice(i, 1);
                    // Create sparkle particles
                    for (let j = 0; j < 5; j++) {
                        gameState.particles.push(new Particle(orb.x, orb.y, '#64c8ff'));
                    }
                    continue;
                }
            }
            orb.draw();
        }

        // Update and draw chests
        for (let i = gameState.chests.length - 1; i >= 0; i--) {
            const chest = gameState.chests[i];
            if (!gameState.isPaused && !gameState.isGameOver) {
                chest.update();
            }
            chest.draw();
        }

        // Update and draw mystery boxes
        if (gameState.mysteryBoxes) {
            for (let i = gameState.mysteryBoxes.length - 1; i >= 0; i--) {
                const box = gameState.mysteryBoxes[i];
                if (!gameState.isPaused && !gameState.isGameOver) {
                    box.update();
                }
                box.draw();
            }
        }

        // Red vignette damage effect
        if (gameState.damageVignette) {
            const elapsed = currentTime - gameState.damageVignette.startTime;
            if (elapsed < gameState.damageVignette.duration) {
                // Fade out over duration
                const progress = elapsed / gameState.damageVignette.duration;
                const currentIntensity = gameState.damageVignette.intensity * (1 - progress);

                // Create radial gradient from center to edges
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);

                const gradient = ctx.createRadialGradient(
                    centerX, centerY, maxRadius * 0.3,
                    centerX, centerY, maxRadius
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(255, 0, 0, ${currentIntensity})`);

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                gameState.damageVignette = null;
            }
        }

        // Restore context after screen shake
        ctx.restore();

        // UI is updated automatically by React
    }

    requestAnimationFrame(gameLoop);
}

// Expose classes globally so React can use them
window.OrbitingOrb = OrbitingOrb;
window.SwordSpinAttack = SwordSpinAttack;
window.Chest = Chest;

// Game will be initialized automatically when sprites finish loading (see sprite loading code above)
